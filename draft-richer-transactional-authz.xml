<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-richer-transactional-authz-08"
     ipr="trust200902">
  <front>
    <title abbrev="transactional-authz">Transactional Authorization</title>

    <author fullname="Justin Richer" initials="J." role="editor"
            surname="Richer">
      <organization>Bespoke Engineering</organization>

      <address>
        <email>ietf@justin.richer.org</email>
      </address>
    </author>

    <date day="22" month="April" year="2020"/>

    <abstract>
      <t>This document defines a mechanism for delegating authorization to a
      piece of software, and conveying that delegation to the software.</t>
    </abstract>

    <note title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119">RFC 2119</xref> <xref target="RFC8174">RFC
      8174</xref> when, and only when, they appear in all capitals, as shown
      here.</t>
    </note>
  </front>

  <middle>
    <section title="Protocol">
      <t>This protocol allows a piece of software to request delegated
      authorization to an API, protected by an authorization server usually on
      behalf of a resource owner.</t>

      <section title="Parties">
        <t>The Authorization Server (AS) manages the transactions. It is
        defined by its transaction endpoint, a single URL that accepts a POST
        request with a JSON payload. The AS MAY also have other endpoints,
        including interaction endpoints and user code endpoints, and these are
        introduced to the RC as needed during the transaction process.</t>

        <t>The Resource Client (RC) requests tokens from the AS and uses
        tokens at the RS.</t>

        <t>The Resource Server (RS) accepts tokens from the RC and validates
        them (potentially at the AS).</t>

        <t>The Resource Owner (RO) authorizes the request from the RC to the
        RS, often interactively at the AS.</t>
      </section>

      <section title="Sequence">
        <t><list style="numbers">
            <t>The RC creates a transaction request and sends it to the AS</t>

            <t>The AS processes the transaction request and determines if the
            RO needs to interact</t>

            <t>If interaction is required, the AS interacts with the RO,
            possibly by directing the RC to send the RO there</t>

            <t>The RC continues the transaction at the AS</t>

            <t>The AS processes the transaction again, determining that a
            token can be issued</t>

            <t>The AS issues a token to the RC</t>

            <t>The RC uses the token with the RS</t>
          </list></t>
      </section>
    </section>

    <section anchor="transaction-request" title="Transaction request">
      <t>To start a transaction, the RC makes a transaction request to the
      transaction endpoint of the AS. The RC creates a JSON <xref
      target="RFC8259"/> document with different sections, included as members
      of a root JSON object. Contents of this section are defined by a
      registry [TBD].</t>

      <t><list style="hanging">
          <t hangText="resources">Information about the RS's the resulting
          token will be applied to, including locations, extents of access,
          types of data being accessed, and other API information. This
          section is REQUIRED.</t>

          <t hangText="key">Information about the keys known to the RC and
          able to be presented in future parts of the transaction. This
          section is REQUIRED. (Note: I can't think of a good reason for this
          to be optional.)</t>

          <t hangText="interact">Information about how the RC is able to
          interact with the RO, including callback URI's and nonce if
          applicable. This section is REQUIRED if the RC is capable of driving
          interaction with the user.</t>

          <t hangText="display">Information about the RC making the request,
          including display name, home page, logo, and other user-facing
          information. This section is RECOMMENDED.</t>

          <t hangText="user">Information about the RO as known to or provided
          to the RC, in the form of assertions or references to external data.
          This section is OPTIONAL.</t>

          <t hangText="claims">Information about the RO as known to or
          provided to the AS being requested by the RS. This section is
          OPTIONAL.</t>

          <t hangText="capabilities">Information about the capabilities of the
          RC. This section is OPTIONAL.</t>
        </list></t>

      <t>Each section consists of either a JSON object or an array of JSON
      objects, as described in the subsections below. Many sections MAY be
      represented by an appropriate handle instead as described in <xref
      target="handles"/>. In such cases, the section is replaced entirely by
      the handle presentation, which is a single string instead of a JSON
      object. The RC MAY present additional sections as defined by extensions
      of this specification. The AS MUST ignore any sections that it does not
      understand.</t>

      <t>A non-normative example of a transaction request is below:</t>

      <t><figure>
          <artwork><![CDATA[{
    "resources": [
        {
            "actions": [
                "read",
                "write",
                "dolphin"
            ],
            "locations": [
                "https://server.example.net/",
                "https://resource.local/other"
            ],
            "datatypes": [
                "metadata",
                "images"
            ]
        },
        "dolphin-metadata"
    ],
    "key": {
        "proof": "jwsd",
        "jwks": {
            "keys": [
                {
                    "kty": "RSA",
                    "e": "AQAB",
                    "kid": "xyz-1",
                    "alg": "RS256",
                    "n": "kOB5rR4Jv0GMeL...."
                }
            ]
        }
    },
    "interact": {
        "redirect": true,
        "callback": {
            "uri": "https://client.example.net/return/123455",
            "nonce": "LKLTI25DK82FX4T4QFZC"
        }
    },
    "display": {
        "name": "My Client Display Name",
        "uri": "https://example.net/client"
    },
    "capabilities":
        ["ext1", "ext2"],
    "claims": {
        "subject": true,
        "email": true,
        "oidc_id_token": true
    }
}]]></artwork>
        </figure></t>

      <t>The request MUST be sent as a JSON obect with content type <spanx
      style="verb">application/json</spanx>, unless otherwise specified by the
      signature mechanism.</t>

      <section anchor="client-request" title="Display">
        <t>This section provides descriptive details of the RC software making
        the call, useful for displaying information about the client to the
        user during the authorization request. This section is a JSON object,
        and all fields are OPTIONAL. The RC MAY send additional fields, and
        the AS MUST ignore all fields that it does not understand. The fields
        of this section will be determined by a registry [TBD].</t>

        <t><list style="hanging">
            <t hangText="name">Display name of the RC software</t>

            <t hangText="uri">User-facing web page of the RC software</t>

            <t hangText="logo_uri">Display image to represent the RC
            software</t>
          </list></t>

        <figure>
          <artwork><![CDATA[    "display": {
        "name": "My Client Display Name",
        "uri": "https://example.net/client"
    }]]></artwork>
        </figure>

        <t/>

        <t>The AS SHOULD use this information in presenting any authorization
        screens to the RO during interaction.</t>

        <t>The display information MAY instead be presented as a display
        handle reference <xref target="client-handle"/>.</t>
      </section>

      <section anchor="resource-request" title="Resource">
        <t>This section identifies what the RC wants to do with the API hosted
        at the RS. When requesting a single resource, this section is a JSON
        array of objects, each object representing a single resource or
        resource set. That AS MUST interpret the request as being for all of
        the resources listed. The fields in this section will be controlled by
        a registry [TBD].</t>

        <t><list style="hanging">
            <t hangText="actions">The types of actions the RC will take at the
            RS</t>

            <t hangText="locations">URIs the RC will call at the RS</t>

            <t hangText="datatypes">types of data available to the RC at the
            RS's API</t>
          </list></t>

        <figure>
          <artwork><![CDATA[    "resources": [
        {
            "actions": [
                "read",
                "write",
                "dolphin"
            ],
            "locations": [
                "https://server.example.net/",
                "https://resource.local/other"
            ],
            "datatypes": [
                "metadata",
                "images"
            ]
        },
        "dolphin-metadata"
    ]]]></artwork>
        </figure>

        <t/>

        <t>This can also be presented as a set of resource handle references
        <xref target="resource-handle"/>, or a combination of handles and
        resource structures.</t>

        <t>When requesting multiple resources, this section is a JSON object
        whose keys identifiers chosen by the RC and whose values are resource
        description arrays, as described above.</t>

        <figure>
          <artwork><![CDATA[    "resources": {
        "token1": [
          {
              "actions": [
                  "read",
                  "write",
                  "dolphin"
              ],
              "locations": [
                  "https://server.example.net/",
                  "https://resource.local/other"
              ],
              "datatypes": [
                  "metadata",
                  "images"
              ]
          },
          "dolphin-metadata"
      ],
      "token2": [
            {
                "actions": [
                    "foo",
                    "bar",
                    "dolphin"
                ],
                "locations": [
                    "https://resource.other/"
                ],
                "datatypes": [
                    "data",
                    "pictures"
                ]
            }
        ]
    }]]></artwork>
        </figure>

        <t/>

        <t>When a client requests multiple resources in this manner, a
        successful response MUST follow the multiple access token format.</t>
      </section>

      <section anchor="user-request" title="User">
        <t>This section provides a verifiable assertion about the person
        interacting with the RC on behalf of the request. This person MAY be
        the RO or MAY be another party. The assertion types will be defined in
        a registry [TBD].</t>

        <t><list style="hanging">
            <t hangText="assertion">The value of the assertion as a
            string.</t>

            <t hangText="type">The type of the assertion. Possible values
            include "oidc_id_token"...</t>
          </list></t>

        <figure>
          <artwork><![CDATA[    "user": {
        "assertion": "eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ.ewogImlzcyI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4Mjg5NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZfV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5NzAsCiAibmFtZSI6ICJKYW5lIERvZSIsCiAiZ2l2ZW5fbmFtZSI6ICJKYW5lIiwKICJmYW1pbHlfbmFtZSI6ICJEb2UiLAogImdlbmRlciI6ICJmZW1hbGUiLAogImJpcnRoZGF0ZSI6ICIwMDAwLTEwLTMxIiwKICJlbWFpbCI6ICJqYW5lZG9lQGV4YW1wbGUuY29tIiwKICJwaWN0dXJlIjogImh0dHA6Ly9leGFtcGxlLmNvbS9qYW5lZG9lL21lLmpwZyIKfQ.rHQjEmBqn9Jre0OLykYNnspA10Qql2rvx4FsD00jwlB0Sym4NzpgvPKsDjn_wMkHxcp6CilPcoKrWHcipR2iAjzLvDNAReF97zoJqq880ZD1bwY82JDauCXELVR9O6_B0w3K-E7yM2macAAgNCUwtik6SjoSUZRcf-O5lygIyLENx882p6MtmwaL1hd6qn5RZOQ0TLrOYu0532g9Exxcm-ChymrB4xLykpDj3lUivJt63eEGGN6DH5K6o33TcxkIjNrCD4XB1CKKumZvCedgHHF3IAK4dVEDSUoGlH9z4pP_eWYNXvqQOjGs-rDaQzUHl6cQQWNiDpWOl_lxXjQEvQ",
        "type": "oidc_id_token"
    }]]></artwork>
        </figure>

        <t/>

        <t>This can also be presented as a user handle reference <xref
        target="user-handle"/>.</t>
      </section>

      <section anchor="interact-request" title="Interact">
        <t>This section provides details of how the RC can interact with the
        RO. All fields are OPTIONAL, and the RC MAY include multiple possible
        interaction modes. If a field is not present, it is interpreted as the
        client's lack support for that feature. The fields in this section are
        defined by a registry [TBD].</t>

        <t><list style="hanging">
            <t hangText="callback">If this object is present, it indicates the
            RC is capable of receiving inbound messages from the RO's browser
            in response to user interaction. This object contains the
            following fields:<list style="hanging">
                <t hangText="uri">REQUIRED. Indicates the URI to send the RO
                to after interaction. This URI MAY be unique per transaction
                and MUST be hosted or accessible by the RC. This URI MUST NOT
                contain any fragment component. This URI MUST be protected by
                HTTPS, be hosted on a server local to the user's browser
                ("localhost"), or use an application-specific URI scheme. If
                the RC needs any state information to tie to the front channel
                interaction response, it MUST encode that into the callback
                URI. The allowable URIs and URI patterns MAY be limited by the
                AS based on the RC's presented key information. The callback
                URI SHOULD be presented to the RO during the interaction phase
                before redirect.</t>

                <t hangText="nonce">REQUIRED. Unique value to be used in the
                calculation of the "hash" query parameter on the callback URL,
                must be sufficiently random to be unguessable by an attacker.
                MUST be generated by the RC as a unique value for this
                transaction.</t>

                <t hangText="hash_method">OPTIONAL. The signature mechanism to
                be used for the callback hash in <xref
                target="interaction-hash"/>. Can be one of sha3 or sha2. If
                absent, the default value is sha3.</t>
              </list></t>

            <t hangText="redirect">If this is set to true, the RC is capable
            of redirecting the RO to an arbitrary interaction URL as described
            in <xref target="user-interaction"/>. The RC MAY communicate the
            URI to the user through a browser redirection, a QR code, or some
            other mechanism.</t>

            <t hangText="user_code">If this is set to true, the RC is capable
            of displaying a short user code to the user and directing them to
            a fixed URL as described in <xref target="user-interaction"/>.</t>

            <t hangText="didcomm">If this is set to true, the RC is capable of
            relaying a DIDComm message to an agent or wallet.</t>

            <t hangText="didcomm_query">If this is set to true, the RC is
            capable of relaying a DIDComm query to an agent or wallet.</t>
          </list></t>

        <t>This section MUST NOT be represented by a handle reference. (Note:
        this decision is largely due to the "callback" section being variable
        per transaction. We could allow a handle but restrict it to
        non-callback methods -- but in that case, it's simpler and shorter to
        just send the booleans instead of having a special case.)</t>

        <t>The following example is from an RC that can redirect to the
        interaction endpoint and receive returns on a callback URI:</t>

        <t><figure>
            <artwork><![CDATA["interact": {
    "redirect": true,
    "callback": {
        "uri": "https://example.com/client/123456",
        "nonce": "VJLO6A4CAYLBXHTR0KRO"
    }
}
]]></artwork>
          </figure></t>
      </section>

      <section anchor="key-request" title="Keys">
        <t>This section lists the keys that the RC can present proof of
        ownership. The RC MUST send at least one key format. The RC MAY send
        more than one key format, but all keys MUST be equivalent. The types
        of keys in this section will be defined by a registry [TBD].</t>

        <t><list style="hanging">
            <t hangText="proof">The form of proof that the RC will use when
            presenting the key to the AS. The valid values of this field and
            the processing requirements for each are detailed in <xref
            target="binding-keys"/>. This field is REQUIRED.</t>

            <t hangText="jwks">Value of the public key as a JWK Set JSON
            object [Note: should this be a single JWK instead? And do we want
            to bother with url-based references?]. MUST contain an "alg" field
            which is used to validate the signature. MUST contain the "kid"
            field to identify the key in the signed object.</t>

            <t hangText="cert">PEM serialized value of the certificate used
            for TLS transactions, with optional internal whitespace.</t>

            <t hangText="cert#256">The certificate thumbprint calculated as
            per <xref target="I-D.ietf-oauth-mtls">OAuth-MTLS</xref>.</t>

            <t hangText="did">The DID URL identifying the key (or keys) used
            to sign this request.</t>
          </list></t>

        <t>The RC MUST provide proof of possession of all presented keys<xref
        target="binding-keys"/>. All presented keys MUST be validated by the
        AS using the method defined by proof.</t>

        <t>This section MAY also be presented as a key handle reference <xref
        target="key-handle"/>. The keys referenced by a handle MUST be
        validated by the AS.</t>

        <t>The following non-normative example shows three key types, with the
        detached JWS proofing mechanism:</t>

        <figure>
          <artwork><![CDATA[    "keys": {
        "proof": "jwsd",
        "jwks": {
            "keys": [
                {
                    "kty": "RSA",
                    "e": "AQAB",
                    "kid": "xyz-1",
                    "alg": "RS256",
                    "n": "kOB5rR4Jv0GMeLaY6_It_r3ORwdf8ci_JtffXyaSx8xY..."
                }
            ]
        },
        "cert": "MIIEHDCCAwSgAwIBAgIBATANBgkqhkiG9w0BAQsFA...",
        "did": "did:example:CV3BVVXK2PWWLCRQLRFU#xyz-1"
    }]]></artwork>
        </figure>
      </section>

      <section anchor="capabilities-request" title="Capabilities">
        <t>This section lists the extensions and special features supported by
        the RC. Values of extensions MUST be listed in [[ a registry ]].</t>

        <t><figure>
            <artwork><![CDATA["capabilities": ["ext1", "ext2"]]]></artwork>
          </figure></t>

        <t>When responding to a request including this field, the AS MAY
        return its own list of supported capabilites. The AS MUST NOT return
        any capability value that the RC did not send in its request.</t>
      </section>

      <section anchor="claims-request" title="Claims">
        <t>This section allows the RC to request identity and authentication
        information about the RO. All fields are OPTIONAL and consist of
        boolean values. A "true" value indicates that the RC is requesting
        that claim be returned in the transaction response. A "false" or
        omitted value indicates that the RC is not requesting that claim be
        returned. The kinds of claims in this section will be defined by a
        registry [TBD].</t>

        <t><list style="hanging">
            <t hangText="subject">A subject identifier for the current
            user.</t>

            <t hangText="email">An email address for the current user.</t>

            <t hangText="phone">A phone number for the current user.</t>

            <t hangText="oidc_id_token">An OpenID Connect ID Token for the
            current user.</t>
          </list></t>

        <t>The following non-normative example shows how to request the
        subject and email address of the current user.</t>

        <t><figure>
            <artwork><![CDATA["claims": {
    "subject": true,
    "email": true
}]]></artwork>
          </figure></t>
      </section>
    </section>

    <section anchor="interact-response" title="Interaction response">
      <t>When evaluating a transaction request, the AS MAY determine that it
      needs to have the RO present to interact with the AS before issuing a
      token. This interaction can include the RO logging in to the AS,
      authorizing the transaction, providing proof claims, determining if the
      transaction decision should be remembered for the future, and other
      items.</t>

      <t>The AS responds to the RC based on the type of interaction supported
      by the RC in the transaction request. The AS MAY respond with multiple
      possible interaction methods to be chosen by the RC. The fields in this
      response are determined by a registry [TBD]. For example, if the RC
      indicates that it can handle redirects and user codes and has a callback
      URI, it would send a transaction request like this:</t>

      <t><figure>
          <artwork><![CDATA[{
    "interact": {
        "redirect": true,
        "user_code": true,
        "callback": {
            "uri": "https://client.example.net/return/123455",
            "nonce": "LKLTI25DK82FX4T4QFZC"
        }
    },
    "resources": [
        "dolphin-metadata"
    ],
    "key": "7C7C4AZ9KHRS6X63AJAO",
    "display": {
        "name": "My Client Display Name",
        "uri": "https://example.net/client"
    }
}]]></artwork>
        </figure></t>

      <t>The AS would then respond with a transaction response like this:</t>

      <t><figure>
          <artwork><![CDATA[{
    "interaction_url": "https://server.example.com/interact/4CF492MLVMSW9MKMXKHQ",
    "server_nonce": "MBDOFXG4Y5CVJCX821LH",
    "user_code": {
        "url": "https://server.example.com/interact/device",
        "code": "A1BC-3DFF"
    },
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    }
}]]></artwork>
        </figure></t>

      <t>This response MUST include a transaction handle as described in <xref
      target="transaction-handle"/> so that the transaction can continue after
      the user has interacted.</t>

      <section anchor="redirect-response" title="Redirect interaction">
        <t>If the RC supports a "redirect" style interaction, the AS creates a
        unique interaction URL and returns it to the RC. This URL MUST be
        associated with the current transaction and no other transaction.</t>

        <t><list style="hanging">
            <t hangText="interaction_url">REQUIRED. The interaction URL that
            the RC will direct the RO to. This URL MUST be unique to this
            transaction request. The URL SHOULD contain a random portion of
            sufficient entropy so as not to be guessable by the user. The URL
            MUST NOT contain the transaction handle or any RC identifying
            information. This URL MUST be protected by HTTPS. This URL MUST
            NOT contain any fragment component.</t>

            <t hangText="handle">REQUIRED. The transaction handle to use in
            the continue the transaction <xref
            target="transaction-continue"/>.</t>
          </list></t>

        <figure>
          <artwork><![CDATA[{
    "interaction_url": "https://server.example.com/interact/4CF492MLVMSW9MKMXKHQ",
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    }
}]]></artwork>
        </figure>

        <t/>

        <t>When the RC receives this response, it MUST launch the system
        browser, redirect the RO through an HTTP 302 response, display the URL
        through a scannable barcode, or otherwise send the RO to the
        interaction URL. The RC MUST NOT modify the interaction URL or append
        anything to it, including any query parameters, fragments, or special
        headers.</t>

        <t>The interaction URL MUST be reachable from the RO's browser, though
        note that the RO MAY open the interaction URL on a separate device
        from the RC itself. The interaction URL MUST be accessible from an
        HTTP GET request, and MUST be protected by HTTPS or equivalent
        means.</t>

        <t>Upon receiving an incoming request at the interaction URL, the AS
        MUST determine the transaction associated with this unique URL. If the
        transaction is not found, an error is returned to the end user through
        the browser and the AS MUST NOT attempt to redirect to a callback URL.
        When interacting with the RO, the AS MAY perform any of the behaviors
        in the User Interaction section <xref target="user-interaction"/>.</t>
      </section>

      <section anchor="callback-response" title="Interaction URI return">
        <t>If the RC has supplied a callback URL in its interact request <xref
        target="interact-request"/>, the AS returns a nonce in its interaction
        response.</t>

        <t><list style="hanging">
            <t hangText="server_nonce">REQUIRED. A unique value from the
            server included in the calculation of the "hash" value returned in
            the callback response. REQUIRED if the client has sent a
            "callback" parameter in its interaction request.</t>
          </list></t>

        <t>This example also includes the interaction URL from <xref
        target="redirect-response"/>.</t>

        <t><figure>
            <artwork><![CDATA[{
    "interaction_url": "https://server.example.com/interact/4CF492MLVMSW9MKMXKHQ",
    "server_nonce": "MBDOFXG4Y5CVJCX821LH",
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    }
}]]></artwork>
          </figure></t>

        <t>When interaction has concluded, the AS returns the user to the RC
        by redirecting the RO's browser to the RC's callback URL presented at
        the start of the transaction, with the addition of two query
        parameters.</t>

        <t><list style="hanging">
            <t hangText="hash">REQUIRED. The interaction hash value as
            described in <xref target="interaction-hash"/>.</t>

            <t hangText="interact_ref">REQUIRED. A shared secret associated
            with this interaction. This value MUST be sufficiently random so
            as not to be guessable by an attacker. This value MUST be
            associated by the AS with the underlying transaction that is
            associated to with this interaction.</t>
          </list></t>

        <t>The AS MUST properly process the callback parameter from the
        interaction request as a URL, adding these values as query parameters.
        The AS MUST NOT use simple string concatenation. For example, for the
        callback URL of "https://example.com/client/123456", the AS would add
        query parameters as follows (newlines added for display purposes
        only):</t>

        <figure>
          <artwork><![CDATA[https://example.com/client/123456
  ?hash=p28jsq0Y2KK3WS__a42tavNC64ldGTBroywsWxT4md_jZQ1R2HZT8BOWYHcLmObM7XHPAdJzTZMtKBsaraJ64A
  &interact_ref=4IFWWIKYBC2PQ6U56NL1]]></artwork>
        </figure>

        <t/>

        <t>Upon processing this request to the callback URL, the RC MUST
        calculate the expected value of the "hash" parameter as described in
        <xref target="interaction-hash"/> and compare that value to the "hash"
        parameter on the incoming request.</t>

        <t>The RC also sends (the hash of? example here is not hashed) the
        interaction reference as the "interact_ref" field of the transaction
        continuation request<xref target="transaction-continue"/>, using the
        transaction handle <xref target="transaction-handle"/> returned in the
        most recent transaction response from the AS.</t>

        <t><figure>
            <artwork><![CDATA[{
    "handle": "80UPRY5NM33OMUKMKSKU",
    "interact_ref": "4IFWWIKYBC2PQ6U56NL1"
}]]></artwork>
          </figure></t>
      </section>

      <section anchor="interaction-hash"
               title="Calculating the interaction hash">
        <t>The "hash" parameter in the interaction response ties the front
        channel response to a transaction by using values known only to the
        parties in the transaction. To calculate the "hash" value for the
        interaction response, the party doing the calculation first takes the
        "nonce" value sent by the RC in the interaction section of the initial
        transaction request <xref target="interact-request"/>, the
        "server_nonce" value returned in the transaction response <xref
        target="callback-response"/>, and the "interact_ref" returned in the
        callback response <xref target="callback-response"/>. These three
        values are concatenated to each other in this order using a single
        newline character as a separator between the fields. There is no
        padding or whitespace before or after any of the lines, and no
        trailing newline character.</t>

        <figure>
          <artwork><![CDATA[VJLO6A4CAYLBXHTR0KRO
MBDOFXG4Y5CVJCX821LH
4IFWWIKYBC2PQ6U56NL1]]></artwork>
        </figure>

        <t/>

        <t>The party then hashes this string with the appropriate algorithm
        based on the "hash_method" parameter of the "callback" section of the
        <xref target="interact-request">interaction request</xref>. If the
        "hash_method" value is not present in the RC's request, the AS
        defaults to "sha3".</t>

        <section title="SHA3">
          <t>The "sha3" hash method consists of hashing the string with the
          512-bit SHA3 algorithm. The byte array is then encoded using URL
          Safe Base64 with no padding. The resulting string is the hash
          value.</t>

          <figure>
            <artwork><![CDATA[p28jsq0Y2KK3WS__a42tavNC64ldGTBroywsWxT4md_jZQ1R2HZT8BOWYHcLmObM7XHPAdJzTZMtKBsaraJ64A]]></artwork>
          </figure>
        </section>

        <section title="SHA2">
          <t>The "sha2" hash method consists of hashing the string with the
          512-bit SHA2 algorithm. The byte array is then encoded using URL
          Safe Base64 with no padding. The resulting string is the hash
          value.</t>

          <figure>
            <artwork><![CDATA[62SbcD3Xs7L40rjgALA-ymQujoh2LB2hPJyX9vlcr1H6ecChZ8BNKkG_HrOKP_Bpj84rh4mC9aE9x7HPBFcIHw]]></artwork>
          </figure>
        </section>
      </section>

      <section anchor="device-response" title="Secondary device interaction">
        <t>If the RC supports a "user_code" style interaction, the AS creates
        a unique user interaction code and returns it to the RC. The RC
        communicates this code to the RO and instructs the RO to enter the
        code at a URL hosted by the AS.</t>

        <t><list style="hanging">
            <t hangText="user_code">REQUIRED. An object containing the user
            code information.<list style="hanging">
                <t hangText="user_code">REQUIRED. A short code that the user
                can type into an authorization server. This string MUST be
                case-insensitive, MUST consist of only easily typeable
                characters (such as letters or numbers). The time in which
                this code will be accepted SHOULD be short lived, such as
                several minutes.</t>

                <t hangText="user_code_url">RECOMMENDED. The interaction URL
                that the RC will direct the RO to. This URL SHOULD be stable
                at the AS such that clients can be statically configured with
                it.</t>
              </list></t>

            <t hangText="wait">RECOMMENDED. The amount of time to wait before
            polling again, in integer seconds. If not specified, the default
            is 30 seconds. See <xref target="wait-response"/>.</t>

            <t hangText="handle">REQUIRED. The transaction handle to use in
            the continue request. See the section on transaction handles<xref
            target="transaction-handle"/>.</t>
          </list></t>

        <figure>
          <artwork><![CDATA[{
    "user_code": {
        "url": "https://server.example.com/interact/device",
        "code": "A1BC-3DFF"
    },
    "wait": 30,
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    }
}]]></artwork>
        </figure>

        <t/>

        <t>When the RC receives this response, it MUST communicate the user
        code to the RO. If possible the RC SHOULD communicate the interaction
        URL to the user as well. However, the URL is generally understood to
        be stable over time for a given service, and this URL MAY be
        communicated through a static means such as the device's documentation
        or packaging.</t>

        <t>When the RO enters the unique user code at the user code URL, the
        AS MUST determine which active transaction is associated with the user
        code. If a transaction is not found, the AS MUST return an error page
        to the user and MUST NOT attempt to redirect to a callback URL. The AS
        MAY use any mechanism to interact with the RO as listed in <xref
        target="user-interaction"/>.</t>

        <t>Note that this method is strictly for allowing the user to enter a
        code at a static URL. If the AS wishes to communicate a pre-composed
        URL to the RO containing both the user code and the URL at which to
        enter it, the AS MUST use the "interaction_url" <xref
        target="redirect-response"/> redirect mechanism instead as this allows
        the client to communicate an arbitrary interaction URL to the RO.</t>
      </section>
    </section>

    <section anchor="wait-response" title="Wait response">
      <t>If the AS needs the RC to wait before it can give a definitive
      response to a transaction continue request<xref
      target="transaction-continue"/>, the AS replies to the transaction
      request with a wait response. This tells the RC that it can poll the
      transaction after a set amount of time.</t>

      <t>This response includes a transaction handle as in Transaction Handle
      <xref target="transaction-handle"/>.</t>

      <t><list style="hanging">
          <t hangText="wait">REQUIRED. The amount of time to wait before
          polling again, in integer seconds.</t>

          <t hangText="handle">REQUIRED. The transaction handle to use in the
          continue request. This MUST be a newly-created handle and MUST
          replace any existing handle for this transaction. See the section on
          transaction handles.</t>
        </list></t>

      <figure>
        <artwork><![CDATA[{
    "wait": 30,
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    }
}]]></artwork>
      </figure>
    </section>

    <section anchor="user-interaction" title="Interaction at the AS">
      <t>When the RO is interacting with the AS at the interaction uri, the AS
      MAY perform whatever actions it sees fit, including but not limited
      to:</t>

      <t><list style="symbols">
          <t>authenticate the RO</t>

          <t>gather identity claims about the RO</t>

          <t>gather consent and authorization from the RO</t>

          <t>allow the RO to modify the parameters of the requested
          transaction (such as disallowing some requested resources)</t>
        </list></t>

      <t>When the AS has concluded interacting with the RO, the AS MUST
      determine if the RC has registered a callback URL and nonce parameter
      for this transaction. If so, the AS MUST redirect the RO's browser to
      the callback URL as described in <xref target="interact-response"/>. If
      the AS detects an error condition, such as an unknown transaction, an
      untrustworthy callback URL, an untrustworthy client, or suspicious RO
      behavior, the AS MUST return an error to the RO's browser and MUST NOT
      redirect to the callback URL.</t>
    </section>

    <section anchor="error-response" title="Error response">
      <t>If the AS determines that the token cannot be issued for any reason,
      it responds to the RC with an error message. This message does not
      include a transaction handle, and the RC can no longer poll for this
      transaction. The RC MAY create a new transaction and start again.</t>

      <t><list style="hanging">
          <t hangText="error">The error code.</t>
        </list></t>

      <figure>
        <artwork><![CDATA[{

  "error": "user_denied"

}]]></artwork>
      </figure>

      <t/>

      <t>TODO: we should have a more robust error mechanism and controlled by
      a registry [TBD]. Current candidate list of errors:</t>

      <t><list style="hanging">
          <t hangText="user_denied">The RO denied the transaction request.</t>

          <t hangText="too_fast">The RC did not respect the timeout in the
          wait response.</t>

          <t hangText="unknown_transaction">The transaction continuation
          request referenced an unknown transaction.</t>

          <t hangText="unknown_handle">The request referenced an unknown
          handle.</t>
        </list></t>
    </section>

    <section anchor="transaction-continue"
             title="Transaction continue request">
      <t>Once a transaction has begun, the AS associates that transaction with
      a transaction handle<xref target="transaction-handle"/> which is
      returned to the RC in one of the transaction responses <xref
      target="redirect-response"/>, <xref target="device-response"/>, <xref
      target="wait-response"/>. This handle MUST be unique, MUST be associated
      with a single transaction, and MUST be one time use.</t>

      <t>The RC continues the transaction by making a request with the
      transaction handle in the body of the request. The RC MAY add additional
      fields to the transaction continuation request, such as the interaction
      reference return in the callback response <xref
      target="interact-response"/>.</t>

      <t><list style="hanging">
          <t hangText="handle">REQUIRED. The (hash of?) transaction handle
          indicating which transaction to continue.</t>

          <t hangText="interaction_ref">OPTIONAL. If the RC has received an
          interaction reference from the callback response of the interaction
          URL, the RC MUST include the (hash of?) that reference in its
          transaction continue request.</t>
        </list></t>

      <figure>
        <artwork><![CDATA[{

  "handle": "tghji76ytghj9876tghjko987yh"

}]]></artwork>
      </figure>

      <t/>

      <t>The RC MUST prove all keys initially sent in the transaction
      request<xref target="key-request"/> as described in <xref
      target="binding-keys"/>.</t>

      <t>The request MUST be sent as a JSON object with content type <spanx
      style="verb">application/json</spanx>, unless specified otherwise by the
      signature mechanism.</t>

      <t>[[ Note: should we allow the client to mutate the transaction at this
      point? We already allow the presentation of the interaction handle, and
      any messaging protocols like DIDComm would allow additional work to be
      done here. But do we want the client to be able to specify additional
      resources, or new interaction methods, or anything like that? I'm
      inclined not to so that's been left out for now. ]]</t>
    </section>

    <section anchor="token-response" title="Transaction response">
      <t>The transaction response contains a set of fields returned as a JSON
      object. The fields of the transaction response will be controlled by a
      registry [TBD].</t>

      <t><list style="hanging">
          <t hangText="access_token">The access token that the RC uses to call
          the RS. The access token follows the handle structure described in
          <xref target="handles"/>. This field is mutually exclusive with the
          multiple_access_tokens field.</t>

          <t hangText="handle">The transaction handle to use in the continue
          request<xref target="transaction-continue"/> to get a new access
          token once the one issued is no longer usable. See the section on
          transaction handles<xref target="transaction-handle"/>.</t>

          <t hangText="claims">The set of claims that the AS asserts for the
          current user. This field is returned only if the RC has requested
          using the "claims" object. This object contains the following
          OPTIONAL fields (the list of available fields will be determined by
          a registry [TBD]):<list style="hanging">
              <t hangText="updated_at">ISO-formatted timestamp string of when
              the user's profile information was last updated. The RC SHOULD
              compare this value to previous values when determining whether
              to get additional user information from an external
              endpoint.</t>

              <t hangText="subject">The machine-readable unique subject
              identifier of the user.</t>

              <t hangText="email">The email address of the user.</t>

              <t hangText="phone">The phone number of the user.</t>

              <t hangText="oidc_id_token">An OpenID Connect ID Token
              representing the user.</t>
            </list></t>

          <t hangText="multiple_access_tokens">If the RC requested multiple
          named resources, this structure contains the access tokens. The keys
          of this JSON object are the labels determined by the RC in its
          request, and the values are the same as a single access_token
          response. This field is mutually exclusive with the access_token
          field.</t>

          <t hangText="display_handle">A value used to represent the
          information in the display object that the client can use in a
          future request, as described in <xref target="client-handle"/>.</t>

          <t hangText="key_handle">A value used to represent the information
          in the key object that the client can use in a future request, as
          described in <xref target="key-handle"/>.</t>

          <t hangText="user_handle">A value used to represent the information
          in the user object that the client can use in a future request, as
          described in <xref target="user-handle"/>.</t>

          <t hangText="resource_handle">A value used to represent the
          information in the resource object that the client can use in a
          future request, as described in <xref
          target="resource-handle"/>.</t>

          <t hangText="claims_handle">A value used to represent the
          information in the claims object that the client can use in a future
          request, as described in <xref target="claims-handle"/>.</t>
        </list></t>

      <t>The following example shows a single access token, a transaction
      handle, and a set of claims about the current user being returned in a
      successful response.</t>

      <figure>
        <artwork><![CDATA[{
    "access_token": {
        "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
        "type": "bearer"
    },
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    },
    "claims": {
        "subject": "UR64TB8N6BW7OZB8CDFONP-MHKUR6",
        "email": "alice@example.com"
    }
}]]></artwork>
      </figure>

      <t/>

      <t>The following example shows multiple access tokens, a key handle, and
      a user handle being returned in a successful response. The RC has chosen
      the labels "token1" and "token2" in this response.</t>

      <figure>
        <artwork><![CDATA[{
    "multiple_access_tokens": {
        "token1": {
            "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
            "type": "bearer"
        },
        "token2": {
            "value": "UFGLO2FDAFG7VGZZPJ3IZEMN21EVU71FHCARP4J1",
            "type": "bearer"
        }
    },
    "user_handle": {
        "value": "XUT2MFM1XBIKJKSDU8QM",
        "type": "bearer"
    },
    "key_handle": {
        "value": "7C7C4AZ9KHRS6X63AJAO",
        "type": "bearer"
    }
}]]></artwork>
      </figure>

      <section title="Presenting Tokens to the RS">
        <t>A bearer style access token MUST be presented using the Header
        method of OAuth 2 Bearer Tokens <xref target="RFC6750"/>. A sha3 style
        access token is hashed as described in <xref
        target="presenting-handles"/> and presented using the Header method of
        OAuth 2 Bearer Tokens <xref target="RFC6750"/>.</t>

        <t>An access token MAY be bound to any keys presented by the client
        during the transaction request. A bound access token MUST be presented
        with proof of the key as described in <xref
        target="binding-keys"/>.</t>
      </section>

      <section title="Additional user information">
        <t>Additional user information MAY be made available to the RC through
        use of an access token at a protected resource representing the user.
        This endpoint could be an OpenID Connect UserInfo Endpoint, a SCIM
        endpoint, or another similar resource. Specification of this resource
        is outside the scope of this specification.</t>
      </section>
    </section>

    <section anchor="handles" title="Handles">
      <t>A handle in this protocol is a value presented from one party to
      another as proof that they are the appropriate party for part of the
      transaction. Handles can be used to reference the transaction as a
      whole, or one of its constituent parts. When a handle is used to
      represent a part of a transaction request, the handle presentation
      replaces the original value. In practical terms, this often means that
      the values of a transaction request are either an object (when the full
      value is used) or a single string (when the handle is used).</t>

      <t><list style="hanging">
          <t hangText="value">The value of the handle as a string.</t>

          <t hangText="type">The verification method, MUST be one of "bearer"
          or "sha3".</t>
        </list></t>

      <section anchor="presenting-handles" title="Presenting handles">
        <t>Bearer handles are presented by giving the exact string value of
        the handle in the appropriate place.</t>

        <t>SHA3 handles are validated by taking the SHA3 hash of the handle
        value and encoding it in Base64URL with no padding, and presenting the
        encoded value.</t>
      </section>

      <section anchor="validating-handles" title="Validating handles">
        <t>Bearer handles are validated by doing an exact byte comparison of
        the string representation of the handle value.</t>

        <t>SHA3 handles are validated by taking the SHA3 hash of the handle
        value and encoding it in Base64URL with no padding, and comparing that
        using an exact byte comparison with the presented value.</t>
      </section>

      <section anchor="transaction-handle" title="Transaction handles">
        <t>Transaction handles are issued by the AS to the RC to allow the RC
        to continue a transaction after every step. A transaction handle MUST
        be discarded after it is used by both the AS and the RC. A transaction
        MUST have only a single handle associated with it at any time. If the
        AS determines that the RC can still continue the transaction after a
        handle has been used, a new transaction handle will be issued in its
        place. If the AS does not issue a transaction handle in its response
        to the RC, the RC MUST NOT continue that transaction.</t>

        <t>Transaction handles always represent the current state of the
        transaction which they reference.</t>

        <t>Transactions can be continued by the RC if the AS needs to interact
        with the RO<xref target="user-interaction"/> and the RC is expecting a
        callback<xref target="interact-response"/> or if the AS is still
        waiting on some external condition<xref target="wait-response"/> while
        the RC is polling. The transaction MAY also be continued after an
        access token is issued <xref target="token-response"/> as a means of
        refreshing an access token with the same rights associated with the
        transaction.</t>
      </section>

      <section anchor="client-handle" title="Display handles">
        <t>RC handles stand in for the display section of the initial
        transaction request<xref target="client-request"/>. The AS MAY issue a
        display handle to a RC as part of a static registration process,
        analogous to a client ID in OAuth 2, allowing the RC to be associated
        with an AS-side configuration that does not change at runtime. Such
        static processes SHOULD be bound to a set of keys known only to the RC
        software.</t>

        <t>Display handles MAY be issued by the RS in response to a
        transaction request. The AS MAY associate the display handle to the
        interact, resource, and key handles issued in the same response,
        requiring them to be used together. When the RC receives this handle,
        it MAY present the handle in future transaction requests instead of
        sending its information again.</t>

        <figure>
          <artwork><![CDATA[{
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    },
    "display_handle": {
        "value": "VBUEOIQA82PBY2ZDJW7Q",
        "type": "bearer"
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The RC sends its handle in lieu of the display block of the
        transaction request:</t>

        <figure>
          <artwork><![CDATA[{

  "display": "absc2948afgdkjnasdf9082ur3kjasdfasdf89"

}]]></artwork>
        </figure>

        <t/>
      </section>

      <section anchor="resource-handle" title="Resource handles">
        <t>Resource handles stand in for the detailed resource request in the
        transaction request<xref target="resource-request"/>. Resource handles
        MAY be created by the authorization server as static stand-ins for
        specific resource requests, analogous to OAuth2 scopes.</t>

        <t>Resource handles MAY be issued by the RS in response to a
        transaction request. In such cases, the resource handle returned
        represents the total of all resources represented in the request.</t>

        <figure>
          <artwork><![CDATA[{
    "wait": 30,
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    },
    "resources_handle": {
        "value": "KLKP36N7GPOKRF3KGH5N",
        "type": "bearer"
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The RC sends its handle in lieu of the resource block of the future
        transaction request:</t>

        <figure>
          <artwork><![CDATA[{

  "resources": ["KLKP36N7GPOKRF3KGH5N"]

}]]></artwork>
        </figure>

        <t/>

        <t>Note that handles and object values MAY be combined in a single
        request.</t>

        <figure>
          <artwork><![CDATA[{
    "resources": [
        {
            "actions": [
                "read",
                "write",
                "dolphin"
            ],
            "locations": [
                "https://server.example.net/",
                "https://resource.local/other"
            ],
            "datatypes": [
                "metadata",
                "images"
            ]
        },
        "dolphin-metadata", 
        "KLKP36N7GPOKRF3KGH5N"
    ]
}]]></artwork>
        </figure>

        <t/>

        <t>If the RC requests multiple named resources to result in multiple
        access tokens, the AS MUST NOT return a resource handle.</t>

        <section title="Resource-first">
          <t>[[ Strawman idea: ]]</t>

          <t>In order to facilitate dynamic API protection, an RS MAY
          pre-register a resource handle in response to an unauthorized
          request from the RC. In this scenario, the RS creates a transaction
          request with no client information but describing the resources
          being protected [[Note: this is currently at odds with the required
          format above, perhaps this should be a special mode or flag? We
          could still use the "keys" section here though.]] The AS returns a
          resource handle to the RS, which then communicates both the resource
          handle and the AS transaction endpoint to the RC. The RC then begins
          its transaction as normal, using the resource handle as one of
          perhaps several resources it requests.</t>
        </section>
      </section>

      <section anchor="user-handle" title="User handles">
        <t>User handles MAY be issued by the AS in response to validating a
        specific RO during a transaction and stand in for the user section of
        a transaction request<xref target="user-request"/>. This handle MAY
        refer to the RO that interacted with the AS, the user presented by
        claims in the transaction request, or a combination of these. This
        handle can be used in future transactions to represent the current
        user, analogous to the persistent claims token of UMA 2.</t>

        <figure>
          <artwork><![CDATA[{
    "wait": 30,
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    },
    "user_handle": {
        "value": "XUT2MFM1XBIKJKSDU8QM",
        "type": "bearer"
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The RC sends its handle in lieu of the user block of the
        transaction request:</t>

        <figure>
          <artwork><![CDATA[{

  "user": "XUT2MFM1XBIKJKSDU8QM"

}]]></artwork>
        </figure>

        <t/>
      </section>

      <section anchor="key-handle" title="Key handles">
        <t>Key handles stand in for the keys section of the initial
        transaction request<xref target="key-request"/>. The AS MAY issue a
        key handle to a RC as part of a static registration process, allowing
        the RC to be associated with an AS-side configuration that does not
        change at runtime.</t>

        <t>Key handles MAY be issued by the AS in response to a transaction
        request. The AS SHOULD bind this handle to the display, resource, and
        user handles issued in the same response. When the RC receives this
        handle, it MAY present the handle in future transaction requests
        instead of sending its information again.</t>

        <figure>
          <artwork><![CDATA[{
    "wait": 30,
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    },
    "key_handle": {
        "value": "7C7C4AZ9KHRS6X63AJAO",
        "type": "bearer"
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The RC sends its handle in lieu of the keys block of the
        transaction request:</t>

        <figure>
          <artwork><![CDATA[{

  "keys": "7C7C4AZ9KHRS6X63AJAO"

}]]></artwork>
        </figure>

        <t/>

        <t>When the AS receives a key handle, it MUST validate that the keys
        referenced by the handle are bound to the current transaction request
        using the proof method referenced by the handle.</t>
      </section>

      <section anchor="claims-handle" title="Claims handles">
        <t>Claims handles stand in for the claims section of the initial
        transaction request<xref target="claims-request"/>. Claims handles MAY
        be created by the authorization server as static stand-ins for
        specific claim set requests, analogous to OIDC scopes.</t>

        <t>Claims handles MAY be issued by the RS in response to a transaction
        request. In such cases, the resource handle returned represents the
        total of all claims requested in the transaction request. When the RC
        receives this handle, it MAY present the handle in future transaction
        requests instead of sending the claims information again.</t>

        <figure>
          <artwork><![CDATA[{
    "wait": 30,
    "handle": {
        "value": "80UPRY5NM33OMUKMKSKU",
        "type": "bearer"
    },
    "claim_handle": {
        "value": "14XF3WKRPKW4RN9AROOC",
        "type": "bearer"
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The RC sends its handle in lieu of the claims block of the
        transaction request:</t>

        <figure>
          <artwork><![CDATA[{

  "claims": "14XF3WKRPKW4RN9AROOC"

}]]></artwork>
        </figure>

        <t/>

        <t>When the AS receives a key handle, it MUST validate that the keys
        referenced by the handle are bound to the current transaction request
        using the proof method referenced by the handle.</t>
      </section>
    </section>

    <section anchor="binding-keys" title="Binding Keys">
      <t>Any keys presented by the RC to the AS or RS MUST be validated as
      part of the transaction in which they are presented.The type of binding
      used is indicated by the proof parameter of the keys section in the
      transaction request. Values defined by this specification are as
      follows:</t>

      <t><list style="hanging">
          <t hangText="jwsd">A detached JWS signature header</t>

          <t hangText="jws">Attached JWS payload</t>

          <t hangText="mtls">Mutual TLS certificate verification</t>

          <t hangText="dpop">OAuth DPoP key proof header</t>

          <t hangText="httpsig">HTTP Signing signature header</t>

          <t hangText="oauthpop">OAuth PoP key proof authentication header</t>
        </list></t>

      <t>Additional values can be defined by a registry [TBD].</t>

      <t>All keys presented by the RC in the transaction request<xref
      target="transaction-request"/> MUST be proved in all transaction
      continuation requests<xref target="transaction-continue"/> for that
      transaction. The AS MUST validate all keys presented by the RC or
      referenced in the transaction at each call to the transaction endpoint.
      The client MUST NOT use a different key during the transaction.</t>

      <section anchor="detached-jws" title="Detached JWS">
        <t>This method is indicated by <spanx style="verb">jwsd</spanx> in the
        <spanx style="verb">proof</spanx> field of a key request. To sign a
        request to the transaction endpoint, the RC takes the serialized body
        of the request and signs it using detached JWS <xref
        target="RFC7797"/>. The header of the JWS MUST contain the kid field
        of the key bound to this RC during this transaction. The JWS header
        MUST contain an alg field appropriate for the key identified by kid
        and MUST NOT be none.</t>

        <t>The RC presents the signature in the JWS-Signature HTTP Header
        field. [Note: this is a custom header field, do we need this?]</t>

        <figure>
          <artwork><![CDATA[JWS-Signature: eyj0....]]></artwork>
        </figure>

        <t/>

        <t>When the AS receives the JWS-Signature header, it MUST parse its
        contents as a detached JWS object. The HTTP Body is used as the
        payload for purposes of validating the JWS, with no
        transformations.</t>
      </section>

      <section title="Attached JWS">
        <t>This method is indicated by <spanx style="verb">jws</spanx> in the
        <spanx style="verb">proof</spanx> field of a key request. To sign a
        request to the transaction endpoint, the RC takes the serialized body
        of the request JSON and signs it using JWS <xref target="RFC7515"/>.
        The header of the JWS MUST contain the kid field of the key bound to
        this RC during this transaction. The JWS header MUST contain an alg
        field appropriate for the key identified by kid and MUST NOT be
        none.</t>

        <t>The RC presents the JWS as the body of the request along with a
        content type of <spanx style="verb">application/jose</spanx>. The AS
        MUST extract the payload of the JWS and treat it as the request body
        for further processing.</t>
      </section>

      <section anchor="mtls" title="Mutual TLS">
        <t>This method is indicated by <spanx style="verb">mtls</spanx> in the
        <spanx style="verb">proof</spanx> field of a key request. The RC
        presents its client certificate during TLS negotiation with the server
        (either AS or RS). The AS or RS takes the thumbprint of the client
        certificate presented during mutual TLS negotiation and compares that
        thumbprint to the thumbprint presented by the RC application as
        described in <xref target="I-D.ietf-oauth-mtls"/> section 3.</t>
      </section>

      <section title="DPoP">
        <t>This method is indicated by <spanx style="verb">dpop</spanx> in the
        <spanx style="verb">proof</spanx> field of a key request. The RC
        creates a DPoP signature header as described in <xref
        target="I-D.fett-oauth-dpop"/> section 2.</t>
      </section>

      <section title="HTTP Signing">
        <t>This method is indicated by <spanx style="verb">httpsig</spanx> in
        the <spanx style="verb">proof</spanx> field of a key request. The RC
        creates an HTTP Signature header as described in <xref
        target="I-D.cavage-http-signatures"/> section 4. The RC MUST calculate
        and present the Digest header as defined in <xref
        target="RFC3230"/>.</t>
      </section>

      <section title="OAuth PoP">
        <t>This method is indicated by <spanx style="verb">oauthpop</spanx> in
        the <spanx style="verb">proof</spanx> field of a key request. The RC
        creates an HTTP Authorization PoP header as described in <xref
        target="I-D.ietf-oauth-signed-http-request"/> section 4, with the
        following additional requirements:</t>

        <t><list style="symbols">
            <t>The at (access token) field MUST be omitted [note: this is in
            contrast to the requirements in the existing spec]</t>

            <t>The b (body hash) field MUST be calculated and supplied</t>
          </list></t>
      </section>
    </section>

    <section title="Discovery">
      <t>By design, the protocol minimizes the need for any pre-flight
      discovery. To begin a transaction, the RC only needs to know the
      transaction endpoint of the AS, and everything else can be negotiated
      dynamically. If the RC wants to optimize its calls to the AS, it MAY
      send an HTTP OPTIONS request to the transaction endpoint to retrieve the
      server's discovery information. The AS responds with a JSON document
      containing the following information:</t>

      <t><list style="hanging">
          <t hangText="transaction_endpoint">REQUIRED. The full URL of the
          AS's transaction endpoint. This MUST match the URL the RC used to
          make the discovery request.</t>

          <t hangText="capabilities">OPTIONAL. A list of the AS's
          capabilities. The values of this result MAY be used by the RC in the
          <xref target="capabilities-request">capabilities section</xref> of
          the transaction request.</t>

          <t hangText="interaction_methods">OPTIONAL. A list of the AS's
          interaction methods. The values of this list correspond to the
          possible fields in the i<xref target="interact-request">nteraction
          section</xref> of the transaction request.</t>

          <t hangText="key_proofs">OPTIONAL. A list of the AS's supported key
          proofing mechanisms. The values of this list correspond to possible
          values of the <spanx style="verb">proof</spanx> field of the <xref
          target="key-request">key section</xref> of the transaction
          request.</t>

          <t hangText="claims">OPTIONAL. A list of the AS's supported claims.
          The values of this list correspond to possible values of the <xref
          target="claims-request">claim section</xref> of the transaction
          request.</t>
        </list></t>

      <t>The information returned from this method is for optimization
      purposes only. The AS MAY deny any request, or any portion of a request,
      even if it lists a capability as supported. For example, a given client
      can be registered with the <spanx style="verb">mtls</spanx> key proofing
      mechanism, but the AS also returns other proofing methods, then the AS
      will deny a request from that client using a different proofing
      mechanism.</t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t/>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>[We'll want a registry for key proof types, and maybe some other
      field names. We'll need to register at least one header and maybe some
      others?]</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>All requests have to be over TLS or equivalent. Many handles act as
      shared secrets, though they can be combined with a requirement to
      provide proof of a key as well.</t>
    </section>

    <section anchor="Privacy" title="Privacy Considerations">
      <t>Handles are passed between parties and therefore should be stateful
      and not contain any internal structure or information, which could leak
      private data.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119.xml'?>

      <?rfc include='reference.RFC.3230.xml'?>

      <?rfc include='reference.RFC.7515.xml'?>

      <?rfc include='reference.RFC.7519.xml'?>

      <?rfc include='reference.RFC.7662.xml'?>

      <?rfc include='reference.RFC.6749.xml'?>

      <?rfc include='reference.RFC.6750.xml'?>

      <?rfc include='reference.RFC.7797.xml'?>

      <?rfc include='reference.RFC.8126.xml'?>

      <?rfc include='reference.RFC.8174.xml'?>

      <?rfc include='reference.RFC.8259.xml'?>

      <?rfc include='reference.I-D.cavage-http-signatures.xml'?>

      <?rfc include='reference.I-D.ietf-oauth-signed-http-request.xml'?>

      <?rfc include='reference.I-D.ietf-oauth-mtls.xml'?>

      <?rfc include='reference.I-D.fett-oauth-dpop.xml'?>

      <reference anchor="BCP195"
                 target="http://www.rfc-editor.org/info/bcp195">
        <front>
          <title>Recommendations for Secure Use of Transport Layer Security
          (TLS) and Datagram Transport Layer Security (DTLS)</title>

          <author fullname="Y. Sheffer" initials="Y." surname="Sheffer">
            <organization/>
          </author>

          <author fullname="R. Holz" initials="R." surname="Holz">
            <organization/>
          </author>

          <author fullname="P. Saint-Andre" initials="P."
                  surname="Saint-Andre">
            <organization/>
          </author>

          <date month="May" year="2015"/>

          <abstract>
            <t>Transport Layer Security (TLS) and Datagram Transport Layer
            Security (DTLS) are widely used to protect data exchanged over
            application protocols such as HTTP, SMTP, IMAP, POP, SIP, and
            XMPP. Over the last few years, several serious attacks on TLS have
            emerged, including attacks on its most commonly used cipher suites
            and their modes of operation. This document provides
            recommendations for improving the security of deployed services
            that use TLS and DTLS. The recommendations are applicable to the
            majority of use cases.</t>
          </abstract>
        </front>

        <seriesInfo name="BCP" value="195"/>

        <seriesInfo name="RFC" value="7525"/>

        <seriesInfo name="DOI" value="10.17487/RFC7525"/>

        <format octets="60283" type="ASCII"/>
      </reference>
    </references>

    <section title="Document History">
      <t>-08</t>

      <t><list style="symbols">
          <t>Added attached JWS signature method.</t>

          <t>Added discovery methods.</t>
        </list></t>

      <t>-07</t>

      <t><list style="symbols">
          <t>Marked sections as being controlled by a future registry TBD.</t>
        </list></t>

      <t>-06</t>

      <t><list style="symbols">
          <t>Added multiple resource requests and multiple access token
          response.</t>
        </list></t>

      <t>-05</t>

      <t><list style="symbols">
          <t>Added "claims" request and response for identity support.</t>

          <t>Added "capabilities" request for inline discovery support.</t>
        </list></t>

      <t>- 04</t>

      <t><list style="symbols">
          <t>Added crypto agility for callback return hash.</t>

          <t>Changed "interaction_handle" to "interaction_ref".</t>
        </list></t>

      <t>- 03</t>

      <t><list style="symbols">
          <t>Removed "state" in favor of "nonce".</t>

          <t>Created signed return parameter for front channel return.</t>

          <t>Changed "client" section to "display" section, as well as
          associated handle.</t>

          <t>Changed "key" to "keys".</t>

          <t>Separated key proofing from key presentation.</t>

          <t>Separated interaction methods into booleans instead of "type"
          field.</t>
        </list></t>

      <t>- 02</t>

      <t><list style="symbols">
          <t>Minor editorial cleanups.</t>
        </list></t>

      <t>- 01</t>

      <t><list style="symbols">
          <t>Made JSON multimodal for handle requests.</t>

          <t>Major updates to normative language and references throughout
          document.</t>

          <t>Allowed interaction to split between how the user gets to the AS
          and how the user gets back.</t>
        </list></t>

      <t>- 00</t>

      <t><list style="symbols">
          <t>Initial submission.</t>
        </list></t>
    </section>
  </back>
</rfc>
