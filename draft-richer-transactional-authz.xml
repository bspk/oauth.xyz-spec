<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-richer-transactional-authz-09"
     ipr="trust200902">
  <front>
    <title abbrev="transactional-authz">XYZ: Grant Negotiation Access
    Protocol</title>

    <author fullname="Justin Richer" initials="J." role="editor"
            surname="Richer">
      <organization>Bespoke Engineering</organization>

      <address>
        <email>ietf@justin.richer.org</email>
      </address>
    </author>

    <date day="15" month="July" year="2020"/>

    <abstract>
      <t>This document defines a mechanism for delegating authorization to a
      piece of software, and conveying that delegation to the software.</t>

      <t>This document is input into the GNAP working group and should be
      referred to as "XYZ" to differentiate it from other proposals.</t>
    </abstract>

    <note title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119">RFC 2119</xref> <xref target="RFC8174">RFC
      8174</xref> when, and only when, they appear in all capitals, as shown
      here.</t>
    </note>
  </front>

  <middle>
    <section title="Protocol">
      <t>This protocol allows a piece of software to request delegated
      authorization to an API, protected by an authorization server usually on
      behalf of a resource owner. The user operating the software may interact
      with the authorization server to authenticate, provide consent, and
      authorize the request.</t>

      <section title="Parties">
        <t>The Authorization Server (AS) manages the transactions. It is
        defined by its grant endpoint, a single URL that accepts a POST
        request with a JSON payload. The AS MAY also have other endpoints,
        including interaction endpoints and user code endpoints, and these are
        introduced to the RC as needed during the transaction process.</t>

        <t>The Resource Client (RC, aka "client") requests tokens from the AS
        and uses tokens at the RS.</t>

        <t>The Resource Server (RS) accepts tokens from the RC and validates
        them (potentially at the AS).</t>

        <t>The Resource Owner (RO) authorizes the request from the RC to the
        RS, often interactively at the AS.</t>

        <t>The User operates the RC and may be the same party as the RO.</t>
      </section>

      <section title="Sequences">
        <t>The RC requests access to an RS, and the AS determines that it
        needs to interact with the user directly to get the RO's consent:<list
            style="numbers">
            <t>The RC <xref target="request">creates a grant request and sends
            it to the AS</xref></t>

            <t>The AS <xref target="response">processes the grant request and
            determines if the RO needs to interact and sends its
            response</xref></t>

            <t>If interaction is required, the <xref
            target="user-interaction">AS interacts with the RO</xref>,
            possibly by directing the RC to send the RO there </t>

            <t>The RC <xref target="continue-request">continues the grant at
            the AS</xref></t>

            <t>The AS processes the transaction again, determining that a
            token can be issued</t>

            <t>The AS issues a token to the RC</t>

            <t>The RC uses the token with the RS</t>
          </list></t>

        <t>[[ Editor's note: More sequences and common connections are needed.
        See <xref target="examples"/> for more specific examples. ]]</t>
      </section>
    </section>

    <section anchor="request" title="Requesting Access">
      <t>To start a request, the client sends <xref
      target="RFC8259">JSON</xref> document with an object as its root. Each
      member of the request object represents a different aspect of the
      client's request.</t>

      <t>A non-normative example of a grant request is below:</t>

      <figure>
        <artwork><![CDATA[{
    "resources": [
        {
            "actions": [
                "read",
                "write",
                "dolphin"
            ],
            "locations": [
                "https://server.example.net/",
                "https://resource.local/other"
            ],
            "datatypes": [
                "metadata",
                "images"
            ]
        },
        "dolphin-metadata"
    ],
    "key": {
        "proof": "jwsd",
        "jwk": {
                    "kty": "RSA",
                    "e": "AQAB",
                    "kid": "xyz-1",
                    "alg": "RS256",
                    "n": "kOB5rR4Jv0GMeL...."
        }
    },
    "interact": {
        "redirect": true,
        "callback": {
            "uri": "https://client.example.net/return/123455",
            "nonce": "LKLTI25DK82FX4T4QFZC"
        }
    },
    "display": {
        "name": "My Client Display Name",
        "uri": "https://example.net/client"
    },
    "capabilities": ["ext1", "ext2"],
    "subject": {
        "id": ["iss-sub", "email"],
        "assertion": ["oidc_id_token"]
    }
}]]></artwork>
      </figure>

      <t/>

      <t>The request MUST be sent as a JSON obect in the body of the HTTP POST
      request with Content-Type <spanx style="verb">application/json</spanx>,
      unless otherwise specified by the signature mechanism.</t>

      <section anchor="request-resource" title="Requesting Resources">
        <t>If the client is requesting one or more access tokens for the
        purpose of accessing an API, the client MUST include a resources
        element. This element MUST be an array (for a single access token) or
        an object (for multiple access tokens), as described in the following
        sections.</t>

        <section anchor="request-resource-single"
                 title="Requesting a Single Access Token">
          <t>When requesting a single access token, the client MUST send a
          resources element containing a JSON array. The elements of the JSON
          array represent rights of access that the client is requesting in
          the access token. The requested access is the sum of all elements
          within the array. These request elements MAY be sent by value as an
          object or by reference as a string. A single resources array MAY
          contain both object and string type resource requests.</t>

          <t>The client declares what access it wants to associated with the
          resulting access token using objects that describe multiple
          dimensions of access. Each object contains a <spanx style="verb">type</spanx>
          property that determines the type of API that the client is calling.
          The value of this field is under the control of the AS and it MAY
          determine which other fields allowed in the object. While it is
          expected that many APIs will have its own properties, a set of
          common properties are defined here. Specific API implementations
          SHOULD NOT re-use these fields with different semantics or syntax.
          [[ Editor's note: this will align with OAuth 2 RAR, but the details
          of how it aligns are TBD ]].</t>

          <t><list style="hanging">
              <t hangText="actions">The types of actions the RC will take at
              the RS as an array of strings. The values of the strings are
              determined by the API being protected.</t>

              <t hangText="locations">The location of the RS as an array of
              strings. These strings are typically URIs, and are determined by
              the API being protected.</t>

              <t hangText="datatypes">Kinds of data available to the RC at the
              RS's API as an array of strings. The values of the strings are
              determined by the API being protected.</t>

              <t hangText="identifier">A string identifier indicating a
              specific resource at the RS. The value of the string is
              determined by the API being protected.</t>
            </list></t>

          <t>The following non-normative example shows the use of both common
          and API-specific elements.</t>

          <figure>
            <artwork><![CDATA[    "resources": [
        {
            "type": "photo-api",
            "actions": [
                "read",
                "write",
                "dolphin"
            ],
            "locations": [
                "https://server.example.net/",
                "https://resource.local/other"
            ],
            "datatypes": [
                "metadata",
                "images"
            ]
        },
        {
            "type": "financial-transaction",
            "actions": [
                "withdraw"
            ],
            "identifier": "account-14-32-32-3", 
            "currency": "USD"
        }
    ]]]></artwork>
          </figure>

          <t/>

          <t>Instead of sending an object, a client MAY send a string known to
          the AS or RS representing the access being requested. Each string
          SHOULD correspond to a specific expanded object representation at
          the AS. [[ Editor's note: we could describe more about how the
          expansion would work. For example, expand into an object where the
          value of the "type" field is the value of the string. Or we could
          leave it open and flexible, since it's really up to the AS/RS to
          interpret. ]] This value is opaque to the client and MAY be any
          valid JSON string, and therefore could include spaces, unicode
          characters, and properly escaped string sequences.</t>

          <figure>
            <artwork><![CDATA[    "resources": [
        "read", "dolphin-metadata", "some other thing"
    ]
]]></artwork>
          </figure>

          <t/>

          <t>A single "resources" array MAY include both object-type and
          string-type resource items.</t>

          <figure>
            <artwork><![CDATA[    "resources": [
        {
            "type": "photo-api",
            "actions": [
                "read",
                "write",
                "dolphin"
            ],
            "locations": [
                "https://server.example.net/",
                "https://resource.local/other"
            ],
            "datatypes": [
                "metadata",
                "images"
            ]
        },
        "read", "dolphin-metadata",
        {
            "type": "financial-transaction",
            "actions": [
                "withdraw"
            ],
            "identifier": "account-14-32-32-3", 
            "currency": "USD"
        },
        "some other thing"
    ]]]></artwork>
          </figure>
        </section>

        <section anchor="request-resource-multiple"
                 title="Requesting Multiple Access Tokens">
          <t>When requesting multiple access tokens, the resources element is
          a JSON object. The names of the JSON object elements are token
          identifiers chosen by the client, and MAY be any valid string. The
          values of the JSON object are JSON arrays representing a single
          access token request, as specified in <xref
          target="response-token-single">requesting a single access
          token</xref>.</t>

          <t>The following non-normative example shows a request for two
          separate access tokens, token1 and token2.</t>

          <figure>
            <artwork><![CDATA[    "resources": {
        "token1": [
          {
              "type": "photo-api",
              "actions": [
                  "read",
                  "write",
                  "dolphin"
              ],
              "locations": [
                  "https://server.example.net/",
                  "https://resource.local/other"
              ],
              "datatypes": [
                  "metadata",
                  "images"
              ]
          },
          "dolphin-metadata"
      ],
      "token2": [
            {
                "type": "walrus-access",
                "actions": [
                    "foo",
                    "bar"
                ],
                "locations": [
                    "https://resource.other/"
                ],
                "datatypes": [
                    "data",
                    "pictures",
                    "walris whiskers"
                ]
            }
        ]
    }]]></artwork>
          </figure>
        </section>
      </section>

      <section anchor="request-subject" title="Requesting User Information">
        <t>If the client is requesting information about the current user from
        the AS, it sends a subject element as a JSON object. This object MAY
        contain the following fields (or additional fields defined in [[
        registry TBD ]]).</t>

        <t><list style="hanging">
            <t hangText="sub-ids">An array of subject identifier subject types
            requested for the user, as defined by <xref
            target="I-D.ietf-secevent-subject-identifiers"/>.</t>

            <t hangText="assertions">An array of requested assertion formats
            defined by [[ registry TBD ]].</t>
          </list></t>

        <figure>
          <artwork><![CDATA["subject": {
   "sub-ids": [ "iss-sub", "email" ],
   "assertions": [ "oidc-id-token", "saml" ]
}]]></artwork>
        </figure>

        <t/>

        <t>If the AS knows the identifier for the current user and has
        permission to do so [[ editor's note: from the user's consent or a
        policy or ... ]], the AS MAY <xref target="response-subject">return
        the user's information in its response</xref>.</t>

        <t>The "sub-ids" and "assertions" request fields are independent of
        each other, and a returned assertion MAY omit a requested subject
        identifier. [[ Editor's note: we're potentially conflating these two
        fields in the same structure, so perhaps these should be split. ]]</t>
      </section>

      <section anchor="request-key" title="Identifying the Client">
        <t>When sending an initial request to the AS, the client MUST identify
        itself by including the key field in the request and by signing the
        request as described in <xref target="binding-keys"/>. This key MAY be
        sent by value or by reference.</t>

        <t>When sent by value, the key MUST be a public key in at least one
        supported format and MUST contain a proof property that matches the
        proofing mechanism used in the request. If the key is sent in multiple
        formats, all the keys MUST be the same. The key presented in this
        field MUST be the key used to sign the request.</t>

        <t><list style="hanging">
            <t hangText="proof">The form of proof that the RC will use when
            presenting the key to the AS. The valid values of this field and
            the processing requirements for each are detailed in <xref
            target="binding-keys"/>. This field is REQUIRED.</t>

            <t hangText="jwk">Value of the public key as a JSON Web Key. MUST
            contain an "alg" field which is used to validate the signature.
            MUST contain the "kid" field to identify the key in the signed
            object.</t>

            <t hangText="cert">PEM serialized value of the certificate used to
            sign the request, with optional internal whitespace.</t>

            <t hangText="cert#256">The certificate thumbprint calculated as
            per <xref target="RFC8705">OAuth-MTLS</xref> in base64 URL
            encoding.</t>
          </list></t>

        <t>Additional key types are defined in [[ registry TBD ]]. Proof types
        are defined in a [[ registry TBD ]] and described in <xref
        target="binding-keys"/>. [[ Editor's note: we will eventually want to
        have fetchable keys, I would guess. Things like DID for key
        identification are going to be important. ]]</t>

        <t>This non-normative example shows a single key presented in multiple
        formats using a single proofing mechanism.</t>

        <figure>
          <artwork><![CDATA[    "key": {
        "proof": "httpsig",
        "jwk": {
                    "kty": "RSA",
                    "e": "AQAB",
                    "kid": "xyz-1",
                    "alg": "RS256",
                    "n": "kOB5rR4Jv0GMeLaY6_It_r3ORwdf8ci_JtffXyaSx8xY..."
        },
        "cert": "MIIEHDCCAwSgAwIBAgIBATANBgkqhkiG9w0BAQsFA..."
    }]]></artwork>
        </figure>

        <t/>

        <t>The AS MAY associate policies with the client software identified
        by this key, such as limiting which resources can be requested and
        which interaciton methods can be used.</t>

        <t>If the client has a reference for its key, the client MAY send that
        reference handle as a string. The format of this string is opaque to
        the client.</t>

        <figure>
          <artwork><![CDATA[{
  "key": "7C7C4AZ9KHRS6X63AJAO"
}]]></artwork>
        </figure>

        <t/>

        <t>If the key is passed by reference, the proofing mechanism
        associated with that key reference MUST also be used. If the AS does
        not recognize the key reference handle, the request MUST be rejected
        with an error.</t>

        <t>If the client identifies its key by reference, the referenced key
        MAY be a symmetric key known to the AS. The client MUST NOT send a
        symmetric key by value.</t>

        <t>The AS MUST ensure that the key represented by this reference is
        the same key used to sign the request as described in <xref
        target="binding-keys"/>.</t>
      </section>

      <section anchor="request-user" title="Identifying the User">
        <t>If the client knows the identity of the current user or one or more
        identifiers for the user, the client MAY send that information to the
        AS in the "user" field. The client MAY pass this information by value
        or by reference.</t>

        <t><list style="hanging">
            <t hangText="sub-ids">An array of subject identifiers for the
            user, as defined by <xref
            target="I-D.ietf-secevent-subject-identifiers"/>.</t>

            <t hangText="assertions">An object containing assertions as values
            keyed on the assertion type defined by [[ registry TBD ]]. [[
            Editor's note: should this be an array of objects with internal
            typing like the sub-ids? Do we expect more than one assertion per
            user anyway? ]]</t>
          </list></t>

        <figure>
          <artwork><![CDATA["user": {
   "sub-ids": [ {
     "subject_type": "email",
     "email": "user@example.com"
   } ],
   "assertions": {
     "oidc-id-token": "eyj..."
   }
}]]></artwork>
        </figure>

        <t/>

        <t>Subject identifiers are hints to the AS in determining the current
        user and MUST NOT be taken as declarative statements that a particular
        user is present at the client. Assertions SHOULD be validated by the
        AS. [[ editor's note: assertion validation is extremely specific to
        the kind of assertion in place ]]</t>

        <t>If the identified user does not match the user present at the AS
        during an interaction step, the AS SHOULD reject the request. [[
        Editor's note: we're potentially conflating identification (sub-ids)
        and provable presence (assertions and a trusted reference handle) in
        the same structure, so perhaps these should be split. ]]</t>

        <t>Additional user assertion formats are defined in [[ registry TBD --
        probably the same registry as requesting formats ]].</t>

        <t>If the client has a reference for the current user at this AS, the
        client MAY pass that reference as a string. The format of this string
        is opaque to the client.</t>

        <figure>
          <artwork><![CDATA["user": "XUT2MFM1XBIKJKSDU8QM"
]]></artwork>
        </figure>

        <t/>

        <t>If the AS trusts the client to present user information, it MAY
        decide, based on its policy, to skip interaction with the user, even
        if the client provides one or more interaction capabilities.</t>
      </section>

      <section anchor="request-interact" title="Interacting with the User">
        <t>If the client is capable of driving interaction with the user, the
        client MAY declare the means that it can interact using the "interact"
        field. This field is a JSON object with keys that declare different
        interaction capabilities. A client MUST NOT declare an interaciton
        capability it does not support.</t>

        <t>The client MAY send multiple capabilities in the same request.
        There is no preference order specified in this request. An AS MAY
        respond to any, all, or none of the presented interaction capabilities
        in a request.</t>

        <t>The following sections detail requests for interaction
        capabilities. Additional interaction capabilities are defined in [[ a
        registry TBD ]].</t>

        <t>[[ Editor's note: there need to be more examples that knit together
        the interaction capabilities into common flows, like an authz-code
        equivalent. But it's important for the protocol design that these are
        separate pieces. ]]</t>

        <figure>
          <artwork><![CDATA[    "interact": {
        "redirect": true,
        "user_code": true,
        "callback": {
            "uri": "https://client.example.net/return/123455",
            "nonce": "LKLTI25DK82FX4T4QFZC"
        }
    }]]></artwork>
        </figure>

        <section anchor="request-interact-redirect"
                 title="Redirect to an Arbitrary URL">
          <t>If the client is capable of directing the user to a URL defined
          by the AS at runtime, the client indicates this by sending the
          "redirect" field with the boolean value "true". The means by which
          the client will activate this URL is out of scope of this
          specification, but common methods include an HTTP redirect,
          launching a browser on the user's device, providing a scannable
          image encoding, and printing out a URL to an interactive
          console.</t>

          <figure>
            <artwork><![CDATA["interact": {
   "redirect": true
}]]></artwork>
          </figure>

          <t/>

          <t>If this interaciton capability is supported for this client and
          request, the AS returns a redirect interaciton response <xref
          target="response-interact-redirect"/>.</t>
        </section>

        <section anchor="request-interact-short"
                 title="Redirect to an Arbitrary Short URL">
          <t>If the client can redirect to a shortened URL defined by the AS
          at runtime, the client indicates this by sending the "redirect"
          field with the boolean value "true". The means by which the client
          will activate this URL is out of scope of this specification, but
          common methods include an HTTP redirect, launching a browser on the
          user's device, providing a scannable image encoding, and printing
          out a URL to an interactive console.</t>

          <figure>
            <artwork><![CDATA["interact": {
   "redirect_short": true
}]]></artwork>
          </figure>

          <t/>

          <t>If this interaction capability is supported for this client and
          request, the AS returns a redirect interaction response with short
          URL <xref target="response-interact-short"/>.</t>

          <t>[[ Editor's note: I'm not sold on this structure as there's a lot
          of overlap with the "redirect" capability, so maybe these should
          merge somehow. Also, I'm not sure if we want additional parameters
          in here, like a max length that the client can support? ]]</t>
        </section>

        <section anchor="request-interact-app"
                 title="Open an Application-specific URL">
          <t>If the client can open a URL associated with an application on
          the user's device, the client indicates this by sending the "app"
          field with boolean value "true". The means by which the client
          determines the application to open with this URL are out of scope of
          this specification.</t>

          <figure>
            <artwork><![CDATA["interact": {
   "app": true
}]]></artwork>
          </figure>

          <t/>

          <t>If this interaction capability is supported for this client and
          request, the AS returns an app interaction response with an app URL
          payload <xref target="response-interact-app"/>.</t>

          <t>[[ Editor's note: this is also similar to the "redirect" above
          today as most apps use captured URLs, but there is likely an
          appetite for splitting the web-based interaction and app-based
          interaction into different URIs. There's also the possibility of
          wanting more in the payload than can be reasonably put into the URL.
          ]]</t>
        </section>

        <section anchor="request-interact-callback"
                 title="Receive a Browser-based Callback">
          <t>If the client is capable of receiving a callback through the
          user's browser at the completion of an interaction, the client
          indicates this by sending the "callback" field. The value of this
          field is an object containing the following members.</t>

          <t><list style="hanging">
              <t hangText="uri">REQUIRED. Indicates the URI to send the RO to
              after interaction. This URI MAY be unique per request and MUST
              be hosted by or accessible by the RC. This URI MUST NOT contain
              any fragment component. This URI MUST be protected by HTTPS, be
              hosted on a server local to the user's browser ("localhost"), or
              use an application-specific URI scheme. If the RC needs any
              state information to tie to the front channel interaction
              response, it MUST encode that into the callback URI. The
              allowable URIs and URI patterns MAY be restricted by the AS
              based on the RC's presented key information. The callback URI
              SHOULD be presented to the RO during the interaction phase
              before redirect.</t>

              <t hangText="nonce">REQUIRED. Unique value to be used in the
              calculation of the "hash" query parameter on the callback URL,
              must be sufficiently random to be unguessable by an attacker.
              MUST be generated by the RC as a unique value for this
              request.</t>

              <t hangText="hash_method">OPTIONAL. The hash calculation
              mechanism to be used for the callback hash in <xref
              target="interaction-hash"/>. Can be one of sha3 or sha2. If
              absent, the default value is sha3. [[ Editor's note: This should
              be expandable via a registry of cryptographic options, and it
              would be good if we didn't define our own identifiers here.
              ]]</t>
            </list></t>

          <figure>
            <artwork><![CDATA["interact": {
    "callback": {
       "uri": "https://client.example.net/return/123455",
       "nonce": "LKLTI25DK82FX4T4QFZC"
    }
}]]></artwork>
          </figure>

          <t/>

          <t>If this interaction capability is supported for this client and
          request, the AS returns a nonce for use in validating <xref
          target="response-interact-callback">the callback response</xref>.
          Requests to the callback URI MUST be processed as described in [[
          processing interaction callbacks ]], and the AS MUST require
          presentation of an interaction callback reference as described in
          <xref target="interaction-callback"/>.</t>

          <t>Since the incoming request to the callback URL is from the user's
          browser, the client MUST require the user to be present on the
          connection. If used with the "pushback" parameter, the two URLs
          SHOULD be different as they have different security properties.</t>

          <t>Note that the means by which the user arrives at the AS is
          declared separately from the user's return using this callback
          mechanism.</t>
        </section>

        <section anchor="request-interact-pushback"
                 title="Receive an HTTP Direct Callback">
          <t>If the client is capable of receiving an HTTP message directly
          from the AS, the client indicates this by sending the "pushback"
          field. The value of this field is an object containing the following
          members.</t>

          <t><list style="hanging">
              <t hangText="uri">REQUIRED. Indicates the URI to send a message
              to after the RO is finished interacting. This URI MAY be unique
              per request and MUST be hosted by or accessible by the RC. This
              URI MUST NOT contain any fragment component. This URI MUST be
              protected by HTTPS and MUST be reachable by the AS. The
              allowable URIs and URI patterns MAY be restricted by the AS
              based on the RC's presented key information.</t>

              <t hangText="nonce">REQUIRED. Unique value to be used in the
              calculation of the "hash" value sent to the pushback URL, must
              be sufficiently random to be unguessable by an attacker. MUST be
              generated by the RC as a unique value for this request.</t>

              <t hangText="hash_method">OPTIONAL. The signature mechanism to
              be used for the callback hash in <xref
              target="interaction-hash"/>. Can be one of sha3 or sha2. If
              absent, the default value is sha3. [[ Editor's note: This should
              be expandable via a registry of cryptographic options, and it
              would be good if we didn't define our own identifiers here.
              ]]</t>
            </list></t>

          <figure>
            <artwork><![CDATA["interact": {
    "pushback": {
       "uri": "https://client.example.net/push/554321",
       "nonce": "82FX4T4QFZCLKLTI25DK"
    }
}]]></artwork>
          </figure>

          <t/>

          <t>If this interaction capability is supported for this client and
          request, the AS returns a nonce for use in validating <xref
          target="response-interact-pushback">the pushback response</xref>.
          Requests to the pushback URI MUST be processed as described in <xref
          target="interaction-pushback"/>, and the AS MUST require
          presentation of an interaction callback reference as described in [
          interaction callback references ].</t>

          <t>Since the incoming request to the pushback URL is from the AS and
          not from the user's browser, the client MUST NOT require the user to
          be present. If used with the "callback" parameter, the two URLs
          SHOULD be different as they have different security properties.</t>

          <t>Note that the means by which the user arrives at the AS is
          declared separately from the user's return using this mechanism.</t>
        </section>

        <section anchor="request-interact-usercode"
                 title="Display a Short Code">
          <t>If the client is capable of displaying or otherwise communicating
          a short, human-entered code to the user, the client indicates this
          by sending the "user_code" field with the boolean value "true". This
          code is to be entered at a static URL that does not change at
          runtime.</t>

          <figure>
            <artwork><![CDATA["interact": {
    "user_code": true
}]]></artwork>
          </figure>

          <t/>

          <t>If this interaction capability is supported for this client and
          request, the AS returns a user code and interaction URL as specified
          in <xref target="interaction-usercode"/>.</t>
        </section>

        <section anchor="request-interact-extend"
                 title="Extending Interaction Capabilities">
          <t>Additional interaction capabilities are defined in [[ a registry
          TBD ]].</t>

          <t>[[ Editor's note: we should have guidance in here about how to
          define other interaction capabilities. There's already interest in
          defining message-based protocols and challenge-response protocols,
          for example. ]]</t>
        </section>
      </section>

      <section anchor="request-display"
               title="Providing Displayable Client Information">
        <t>If the client has additional information to display to the user
        during any interactions at the AS, it MAY send that information in the
        "display" field. This field is a JSON object that declares information
        to present to the user during any interactive sequences.</t>

        <t><list style="hanging">
            <t hangText="name">Display name of the RC software</t>

            <t hangText="uri">User-facing web page of the RC software</t>

            <t hangText="logo_uri">Display image to represent the RC
            software</t>
          </list></t>

        <figure>
          <artwork><![CDATA[    "display": {
        "name": "My Client Display Name",
        "uri": "https://example.net/client"
    }]]></artwork>
        </figure>

        <t/>

        <t>Additional display fields are defined by [[ a registry TBD. ]]</t>

        <t>The AS SHOULD use these values during interaction with the user.
        The AS MAY restrict display values to specific clients, as identified
        by their keys.</t>

        <t>[[ Editor's note: this might make sense to combine with the "key"
        field, but some classes of more dynamic client vary those fields
        separately. We should also consider things like signed statements for
        client attestation, but that might fit better into a different
        top-level field instead. ]]</t>
      </section>

      <section anchor="request-capabilities"
               title="Declaring Client Capabilities">
        <t>If the client supports extension capabilities, it MAY present them
        to the AS in the "capabilities" field. This field is an array of
        strings representing specific extensions and capabilities, as defined
        by [[ a registry TBD ]].</t>

        <figure>
          <artwork><![CDATA["capabilities": ["ext1", "ext2"]]]></artwork>
        </figure>
      </section>

      <section anchor="request-existing"
               title="Referencing an Existing Grant Request">
        <t>If the client has a reference handle from a previously granted
        request, it MAY send that reference in the "reference" field. This
        field is a single string.</t>

        <figure>
          <artwork><![CDATA["existing_grant": "80UPRY5NM33OMUKMKSKU"]]></artwork>
        </figure>

        <t/>

        <t>The AS MUST dereference the grant associated with the reference and
        process this request in the context of the referenced one.</t>

        <t>[[ Editor's note: this basic capability is to allow for both
        step-up authorization and downscoped authorization, but by explicitly
        creating a new request and not modifying an existing one. What's the
        best guidance for how an AS should process this? ]]</t>
      </section>

      <section anchor="request-extending" title="Extending The Grant Request">
        <t>The request object MAY be extended by registering new items in [[ a
        registry TBD ]]. Extensions SHOULD be orthogonal to other parameters.
        Extensions MUST document any aspects where the</t>

        <t>[[ Editor's note: we should have more guidance and examples on what
        possible top-level extensions would look like. Things like an OIDC
        "claims" request or a VC query, for example. ]]</t>
      </section>
    </section>

    <section anchor="response" title="Grant Response">
      <t>In response to a client's request, the AS responds with a JSON object
      as the HTTP entity body.</t>

      <figure>
        <artwork><![CDATA[{
    "access_token": {
        "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
        "proof": "bearer",
        "manage": "https://server.example.com/token/PRY5NM33OM4TB8N6BW7OZB8CDFONP219RP1L"
    },
    "continue": {
        "handle": "80UPRY5NM33OMUKMKSKU",
        "uri": "https://server.example.com/continue"
    },
    "subject": {
        "sub-ids": [ {
           "subject_type": "email",
           "email": "user@example.com",
        } ]
    }
}]]></artwork>
      </figure>

      <section anchor="response-continue" title="Request Continuation Handle">
        <t>If the AS determines that the request can be continued with
        additional requests, it responds with the "continue" field. This field
        contains a JSON object with the following properties.</t>

        <t><list style="hanging">
            <t hangText="handle">REQUIRED. A unique reference for the grant
            request.</t>

            <t hangText="uri">REQUIRED. The URI at which the client can make
            continuation requests. This URI MAY vary per client or ongoing
            request.</t>

            <t hangText="wait">RECOMMENDED. The amount of time in integer
            seconds the client SHOULD wait after receiving this continuation
            handle and calling the URI.</t>

            <t hangText="expires_in">OPTIONAL. The number of seconds in which
            the handle will expire. The client MUST NOT use the handle past
            this time. The handle MAY be revoked at any point prior to its
            expiration.</t>
          </list></t>

        <figure>
          <artwork><![CDATA[{
    "continue": {
        "handle": "80UPRY5NM33OMUKMKSKU",
        "uri": "https://server.example.com/continue",
        "wait": 60
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The client can use the values of this field as described in <xref
        target="continue-request"/>.</t>

        <t>This field SHOULD be returned when interaction is expected, to
        allow the client to follow up after interaction has been
        concluded.</t>
      </section>

      <section anchor="response-token" title="Access Tokens">
        <t>If the AS has successfully granted one or more access tokens, it
        responds with one of these fields. The AS MUST NOT respond with both
        fields.</t>

        <t>[[ Editor's note: I really don't like the dichotomy between
        "access_token" and "multiple_access_tokens" and their being mutually
        exclusive, and I think we should design away from this pattern toward
        something less error-prone. ]]</t>

        <section anchor="response-token-single" title="Single Access Token">
          <t>If the client has requested a single access token and the AS has
          granted that access token, the AS responds with the "access_token"
          field. The value of this field is an object with the following
          properties.</t>

          <t><list style="hanging">
              <t hangText="value">REQUIRED. The value of the access token as a
              string. The value is opaque to the client. The value SHOULD be
              limited to ASCII characters to facilitate transmission over HTTP
              headers and elements without additional encoding.</t>

              <t hangText="proof">REQUIRED. The proofing presentation
              mechanism used for presenting this access token to an RS. See
              <xref target="send-access-token">the section on sending access
              tokens</xref> for details on possible values to this field and
              their requirements.</t>

              <t hangText="manage">OPTIONAL. The management URI for this
              access token. If provided, the client MAY manage its access
              token as described in <xref target="token-management">managing
              an access token lifecycle</xref>. This URI MUST NOT include the
              access token value and MUST be different for each access
              token.</t>

              <t hangText="resources">OPTIONAL. A description of the rights
              associated with this access token, as defined in <xref
              target="response-token-single">requesting resource
              access</xref>. If included, this MUST reflect the rights
              associated with the issued access token. These rights MAY vary
              from what was requested by the client.</t>

              <t hangText="expires_in">OPTIONAL. The number of seconds in
              which the access will expire. The client MUST NOT use the access
              token past this time. The access token MAY be revoked at any
              point prior to its expiration.</t>

              <t hangText="key">The key that the token is bound to, REQUIRED
              if the token is sender-constrained. The key MUST be in a format
              described in <xref target="request-key"/>. [[ Editor's note:
              this isn't quite right, since the request section includes a
              "proof" field that we already have here. A possible solution
              would be to only have a "key" field as defined above and its
              absence indicates a bearer token? ]]</t>
            </list></t>

          <figure>
            <artwork><![CDATA[    "access_token": {
        "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
        "proof": "bearer",
        "manage": "https://server.example.com/token/PRY5NM33OM4TB8N6BW7OZB8CDFONP219RP1L",
        "resources": [
            {
                "type": "photo-api",
                "actions": [
                    "read",
                    "write",
                    "dolphin"
                ],
                "locations": [
                    "https://server.example.net/",
                    "https://resource.local/other"
                ],
                "datatypes": [
                    "metadata",
                    "images"
                ]
            },
            "read", "dolphin-metadata"
        ]
    }]]></artwork>
          </figure>

          <t/>
        </section>

        <section anchor="response-token-multiple"
                 title="Multiple Access Tokens">
          <t>If the client has requested multiple access tokens and the AS has
          granted at least one of them, the AS responds with the
          "multiple_access_tokens" field. The value of this field is a JSON
          object, and the property names correspond to the token identifiers
          chosen by the client in the <xref
          target="request-resource-multiple">multiple access token request
          </xref>. The values of the properties of this object are access
          tokens as descibed in <xref target="response-token-single"/>.</t>

          <figure>
            <artwork><![CDATA[    "multiple_access_tokens": {
        "token1": {
            "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
            "proof": "bearer",
            "manage": "https://server.example.com/token/PRY5NM33OM4TB8N6BW7OZB8CDFONP219RP1L"
        },
        "token2": {
            "value": "UFGLO2FDAFG7VGZZPJ3IZEMN21EVU71FHCARP4J1",
            "proof": "bearer"
        }
    }]]></artwork>
          </figure>

          <t/>

          <t>Each access token corresponds to the named resources arrays in
          the client's request. The AS MAY not issue one or more of the
          requested access tokens. In such cases all of the issued access
          tokens are included without the omitted token. The multiple access
          token response MUST be used when multiple access tokens are
          requested, even if only one access token is issued.</t>

          <t>If the client <xref target="request-resource-single">requested a
          single access token</xref>, the AS MUST NOT respond with multiple
          access tokens.</t>

          <t>Each access token MAY have different proofing mechanisms. If
          used, each access token MUST have different management URIs.</t>
        </section>
      </section>

      <section anchor="response-interact" title="Interaction Capabilities">
        <t>If the client has indicated a capability to interact with the user
        in its request, and the AS has determined that interaction is both
        supported and necessary, the AS responds to the client with any of the
        following values. There is no preference order for interaction
        capabilities in the response, and it is up to the client to determine
        which ones to use.</t>

        <t>[[ Editor's note: Currently these are all in the root of the
        response, but should they be bundled into an "interact" sub-object?
        This would match the request pattern. ]]</t>

        <section anchor="response-interact-redirect"
                 title="Redirection to an arbitrary URL">
          <t>If the client indicates that it can <xref
          target="request-interact-redirect">redirect to an arbitrary
          URL</xref> and the AS supports this capability for the client's
          request, the AS responds with the "interaction_url" field, which is
          a string containing the URL to direct the user to. This URL MUST be
          unique for the request and MUST NOT contain any security-sensitive
          information.</t>

          <figure>
            <artwork><![CDATA["interaction_url": "https://server.example.com/interact/4CF492MLVMSW9MKMXKHQ"]]></artwork>
          </figure>

          <t/>

          <t>The client sends the user to the URL to interact with the AS. The
          client MUST NOT alter the URL in any way. The means for the client
          to send the user to this URL is out of scope of this specification,
          but common methods include an HTTP redirect, launching the system
          browser, displaying a scannable code, or printing out the URL in an
          interactive console.</t>

          <t>[[ Editor's note: should we rename this to "redirect" to match
          the request? Downside: it conflicts with OAuth 2's "redirect_uri"
          concept. ]]</t>
        </section>

        <section anchor="response-interact-short"
                 title="Redirection to a short URL">
          <t>If the client indicates that it can <xref
          target="request-interact-short">redirect to an arbitrary short
          URL</xref> and the AS supports this capability for the client's
          request, the AS responds with the "short_interaction_url" field,
          which is a string containing the URL to direct the user to. This URL
          MUST be unique for the request and MUST NOT contain any
          security-sensitive information.</t>

          <figure>
            <artwork><![CDATA["short_interaction_url": "https://srv.ex/MXKHQ"]]></artwork>
          </figure>

          <t/>

          <t>The client sends the user to the URL to interact with the AS. The
          client MUST NOT alter the URL in any way. The means for the client
          to send the user to this URL is out of scope of this specification,
          but common methods include displaying a scannable code, or printing
          out the URL in an interactive console.</t>

          <t>[[ Editor's note: should we rename this to "short_redirect" to
          match the request? Downside: it kinda conflicts with OAuth 2's
          "redirect_uri" concept. ]]</t>
        </section>

        <section anchor="response-interact-app"
                 title="Launch of an application URL">
          <t>If the client indicates that it can <xref
          target="request-interact-app">launch an application URL</xref> and
          the AS supports this capability for the client's request, the AS
          responds with the "app" field, which is a string containing the URL
          to direct the user to. This URL MUST be unique for the request and
          MUST NOT contain any security-sensitive information.</t>

          <figure>
            <artwork><![CDATA["app_url": "https://app.example.com/4CF492MLVMSW9MKMXKHQ"]]></artwork>
          </figure>

          <t/>

          <t>The client launches the URL. The client MUST NOT alter the URL in
          any way. The means for the client to launch this URL is out of scope
          of this specification.</t>

          <t>[[ Editor's note: This will probably need to be expanded to an
          object to account for other parameters needed in app2app use cases,
          like addresses for distributed storage systems, server keys, and the
          like. Details TBD as people build this out. ]]</t>
        </section>

        <section anchor="response-interact-callback"
                 title="Callback to a Client URL">
          <t>If the client indicates that it can <xref
          target="request-interact-callback">receive a post-interaction
          callback on a URL</xref> and the AS supports this capability for the
          client's request, the AS responds with a "callback_server_nonce"
          that the client will use in validating the callback as defined in
          <xref target="interaction-hash"/>.</t>

          <figure>
            <artwork><![CDATA["callback_server_nonce": "MBDOFXG4Y5CVJCX821LH"]]></artwork>
          </figure>

          <t/>

          <t>If the AS returns a "callback_server_nonce", the client MUST NOT
          continue a grant request before it receives the associated
          interaction reference on the callback URI. If both the "callback"
          and "pushback" capabilities are available, the client MAY use either
          value.</t>

          <t>[[ Editor's note: should we rename this "callback" and/or put it
          in an object to match the request? That feels like an overfit to me,
          though. ]]</t>
        </section>

        <section anchor="response-interact-pushback"
                 title="Push to a Client URL">
          <t>If the client indicates that it can <xref
          target="request-interact-pushback">receive a post-interaction push
          on a URL</xref> and the AS supports this capability for the client's
          request, the AS responds with a "pushback_server_nonce" that the
          client will use in validating the pushback call as defined in <xref
          target="interaction-hash"/>.</t>

          <figure>
            <artwork><![CDATA["pushback_server_nonce": "MBDOFXG4Y5CVJCX821LH"]]></artwork>
          </figure>

          <t/>

          <t>If the AS returns a "pushback_server_nonce", the client MUST NOT
          continue a grant request before it receives the associated
          interaction reference on the pushback URI. If both the "callback"
          and "pushback" capabilities are available, the client MAY use either
          value.</t>

          <t>[[ Editor's note: should we rename this "pushback" and/or put it
          in an object to match the request? That feels like an overfit to me,
          though. ]]</t>
        </section>

        <section anchor="response-interact-usercode"
                 title="Display of a Short Code">
          <t>If the client indicates that it can <xref
          target="request-interact-usercode">display a short user-typable
          code</xref> and the AS supports this capability for the client's
          request, the AS responds with a "user_code" field. This field is an
          object that contains the following members.</t>

          <t><list style="hanging">
              <t hangText="code">REQUIRED. A unique short code that the user
              can type into an authorization server. This string MUST be
              case-insensitive, MUST consist of only easily typeable
              characters (such as letters or numbers). The time in which this
              code will be accepted SHOULD be short lived, such as several
              minutes. It is RECOMMENDED that this code be no more than eight
              characters in length.</t>

              <t hangText="url">RECOMMENDED. The interaction URL that the RC
              will direct the RO to. This URL MUST be stable at the AS such
              that clients can be statically configured with it.</t>
            </list></t>

          <figure>
            <artwork><![CDATA[    "user_code": {
        "code": "A1BC-3DFF",
        "url": "https://srv.ex/device"
    }
]]></artwork>
          </figure>

          <t/>

          <t>The client MUST communicate the "code" to the user in some
          fashion, such as displaying it on a screen or reading it out
          audibly. The client SHOULD also communicate the URL if possible. As
          this interaction capability is designed to facilitate interaction
          via a secondary device, it is not expected that the client redirect
          the user to the URL. If the client is capable of communicating an
          arbitrary URL to the user, such as through a scannable code, the
          client SHOULD use the <xref
          target="request-interact-redirect">"redirect"</xref> or <xref
          target="request-interact-short">"short_redirect"</xref> capabilities
          for this purpose.</t>
        </section>

        <section title="Extending Interaction Capability Responses">
          <t>Extensions to this specification can define new interaction
          capability responses in [[ a registry TBD ]].</t>
        </section>
      </section>

      <section anchor="response-subject" title="Returning User Information">
        <t>If information about the current user is requested and the AS
        grants the client access to that data, the AS returns the approved
        information in the "subject" response field. This field is an object
        with the following properties.</t>

        <t><list style="hanging">
            <t hangText="sub-ids">An array of subject identifiers for the
            user, as defined by <xref
            target="I-D.ietf-secevent-subject-identifiers"/>. [[ Editor's
            note: privacy considerations are needed around returning
            identifiers. ]]</t>

            <t hangText="assertions">An object containing assertions as values
            keyed on the assertion type defined by [[ registry TBD ]]. [[
            Editor's note: should this be an array of objects with internal
            typing like the sub-ids? Do we expect more than one assertion per
            user anyway? ]]</t>
          </list></t>

        <figure>
          <artwork><![CDATA["subject": {
   "sub-ids": [ {
     "subject_type": "email",
     "email": "user@example.com",
   } ],
   "assertions": {
     "oidc-id-token": "eyj..."
   }
}]]></artwork>
        </figure>

        <t/>

        <t/>
      </section>

      <section anchor="response-dynamic-handles"
               title="Returning Dynamically-bound Reference Handles">
        <t>Many parts of the client's request can be passed as either a value
        or a reference. Some of these references, such as for the client's
        keys or the resources, can sometimes be managed statically through an
        admin console or developer portal provided by the AS or RS. If
        desired, the AS MAY also generate and return some of these references
        dynamically to the client in its response to facilitate multiple
        interactions with the same software. The client SHOULD use these
        references in future requests in lieu of sending the associated data
        value. These handles are intended to be used on future requests.</t>

        <t>Dynamically generated handles are string values that MUST be
        protected by the client as secrets. Handle values MUST be unguessable
        and MUST NOT contain any sensitive information. Handle values are
        opaque to the client. [[ Editor's note: these used to be objects to
        allow for expansion to future elements, like a management URI or
        different presentation types or expiration, but those weren't used in
        practice. Is that desirable anymore or is collapsing them like this
        the right direction? ]]</t>

        <t>All dynamically generated handles are returned as fields in the
        root JSON object of the response. This specification defines the
        following dynamic handle returns, additional handles can be defined [[
        in a registry TBD ]].</t>

        <t><list style="hanging">
            <t hangText="key_handle">A value used to represent the information
            in the key object that the client can use in a future request, as
            described in <xref target="request-key"/>.</t>

            <t hangText="display_handle">A value used to represent the
            information in the display object that the client can use in a
            future request, as described in <xref
            target="request-display"/>.</t>

            <t hangText="user_handle">A value used to represent the current
            user. The client can use in a future request, as described in
            <xref target="request-user"/>.</t>
          </list></t>

        <t>This non-normative example shows two handles along side an issued
        access token.</t>

        <figure>
          <artwork><![CDATA[{
    "user_handle": "XUT2MFM1XBIKJKSDU8QM",
    "key_handle": "7C7C4AZ9KHRS6X63AJAO",
    "access_token": {
        "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
        "proof": "bearer"
    }
}]]></artwork>
        </figure>
      </section>

      <section anchor="error-response" title="Error response">
        <t>If the AS determines that the request cannot be issued for any
        reason, it responds to the RC with an error message.</t>

        <t><list style="hanging">
            <t hangText="error">The error code.</t>
          </list></t>

        <figure>
          <artwork><![CDATA[{

  "error": "user_denied"

}]]></artwork>
        </figure>

        <t/>

        <t>The error code is one of the following, with additional values
        available in [[ a registry TBD ]]:</t>

        <t><list style="hanging">
            <t hangText="user_denied">The RO denied the request.</t>

            <t hangText="too_fast">The RC did not respect the timeout in the
            wait response.</t>

            <t hangText="unknown_handle">The request referenced an unknown
            handle.</t>
          </list></t>

        <t>[[ Editor's note: I think we will need a more robust error
        mechanism, and we need to be more clear about what error states are
        allowed in what circumstances. Additionally, is the "error" parameter
        exclusive with others in the return? ]]</t>
      </section>

      <section title="Extending the Response">
        <t>Extensions to this specification MAY define additional fields for
        the grant response in [[ a registry TBD ]].</t>

        <t>[[ Editor's note: what guidance should we give to designers on
        this? ]]</t>
      </section>
    </section>

    <section anchor="user-interaction" title="Interaction at the AS">
      <t>If the client <xref target="request-interact">indicates that it is
      capable of driving interaction with the user in its request</xref>, and
      the AS determines that interaction is required, the client SHOULD
      initiate one of the returned <xref
      target="response-interact">interaction capabilities in the
      response</xref>.</t>

      <t>When the RO is interacting with the AS, the AS MAY perform whatever
      actions it sees fit, including but not limited to:</t>

      <t><list style="symbols">
          <t>authenticate the user as RO</t>

          <t>gather consent and authorization from the RO for access to
          requested resources or the</t>

          <t>allow the RO to modify the parameters of the request (such as
          disallowing some requested resources or specifying an account or
          record)</t>
        </list></t>

      <t>[[ Editor's note: there are some privacy and security considerations
      here but for the most part we don't want to be overly prescriptive about
      the UX, I think. ]]</t>

      <section anchor="interaction-redirect"
               title="Interaction at a Redirected URI">
        <t>When the user is directed to the AS through the <xref
        target="response-interact-redirect">"interaction_url"</xref> or <xref
        target="response-interact-short">"short_interaction_url"</xref>
        capabilities, the AS can interact with the user through their web
        browser to authenticate the user as an RO and gather their consent.
        Note that since the client does not add any parameters to the URL, the
        AS MUST determine the grant request being referenced from the URL
        value itself. If the URL cannot be associated with a currently active
        request, the AS MUST display an error to the user and MUST NOT attempt
        to redirect the user back to any client.</t>

        <t>The interaction URL MUST be reachable from the RO's browser, though
        note that the RO MAY open the URL on a separate device from the RC
        itself. The interaction URL MUST be accessible from an HTTP GET
        request, and MUST be protected by HTTPS or equivalent means.</t>
      </section>

      <section anchor="interaction-usercode"
               title="Interaction at the User Code URI">
        <t>When the user is directed to the AS through the <xref
        target="response-interact-usercode">"user_code"</xref> capability, the
        AS can interact with the user through their web browser to collect the
        user code, authenticate the user as an RO, and gather their consent.
        Note that since the URL itself is static, the AS MUST determine the
        grant request being referenced from the user code value itself. If the
        user code cannot be associated with a currently active request, the AS
        MUST display an error to the user and MUST NOT attempt to redirect the
        user back to any client.</t>

        <t>The user code URL MUST be reachable from the RO's browser, though
        note that the RO MAY open the URL on a separate device from the RC
        itself. The user code URL MUST be accessible from an HTTP GET request,
        and MUST be protected by HTTPS or equivalent means.</t>
      </section>

      <section anchor="interaction-app"
               title="Interaction through an Application URI">
        <t>When the user successfully launches an application through the
        <xref target="response-interact-app">"app" capability</xref>, the AS
        interacts with the user through that application to authenticate the
        user as the RO and gather their consent. The details of this
        interaction are out of scope for this specification.</t>

        <t>[[ Editor's note: Should we have anything to say about an app
        sending information to a back-end to get details on the pending
        request? ]]</t>
      </section>

      <section anchor="interaction-finalize" title="Finalizing Interaction">
        <t>Upon completing an interaction with the user, if either a <xref
        target="response-interact-callback">"callback"</xref> or <xref
        target="response-interact-pushback">"pushback"</xref> capability is
        available with the current request, the AS MUST follow the appropriate
        method at the end of interaction to allow the client to continue. If
        neither capability is available, the AS SHOULD instruct the user to
        return to their client software upon completion. Note that these steps
        still take place in most error cases, such as when the user has denied
        access. This allows the client to potentially recover from the error
        state without restarting. [[ Editor's note: there might be some other
        kind of push-based notification or callback that the client can use,
        or an out-of-band protocol. The AS would know about this if supported
        and used, but the guidance here should be written in such a way as to
        not be too restrictive in the next steps that it can take. Still, it's
        important that the AS not expect clients to poll if the client has
        stated it can take a callback. ]]</t>

        <t>The AS MUST calculate a hash value as described in <xref
        target="interaction-hash"/>. The client will use this value to
        validate the return call from the AS.</t>

        <t>The AS MUST create an interaction reference and associate that
        reference with the current interaction and the underlying pending
        request. This value MUST be sufficiently random so as not to be
        guessable by an attacker.</t>

        <t>The AS then MUST send the hash and interaction reference based on
        the interaction finalization capability as described in the following
        sections. If both the "callback" and "pushback" capabilities are
        available for the current request, the AS MUST choose only one. [[
        Editor's note: is this restriction necessary? ]]</t>

        <section anchor="interaction-callback"
                 title="Finalizing Interaction with a Callback URI">
          <t>When using the <xref
          target="response-interact-callback">"callback" interaction
          capability</xref>, the AS signals to the client that interaction is
          complete and the request can be continued by directing the user (in
          their browser) back to the client's callback URL sent in <xref
          target="request-interact-callback">the callback request</xref>.</t>

          <t>The AS secures this callback by adding the hash and interaction
          reference as query parameters to the client's callback URL.</t>

          <t><list style="hanging">
              <t hangText="hash">REQUIRED. The interaction hash value as
              described in <xref target="interaction-hash"/>.</t>

              <t hangText="interact_ref">REQUIRED. The interaction reference
              generated for this interaction.</t>
            </list></t>

          <t>The means of directing the user to this URL are outside the scope
          of this specification, but common options include redirecting the
          user from a webpage and launching the system browser with the target
          URL.</t>

          <figure>
            <artwork><![CDATA[https://client.example.net/return/123455
  ?hash=p28jsq0Y2KK3WS__a42tavNC64ldGTBroywsWxT4md_jZQ1R2HZT8BOWYHcLmObM7XHPAdJzTZMtKBsaraJ64A
  &interact_ref=4IFWWIKYBC2PQ6U56NL1]]></artwork>
          </figure>

          <t/>

          <t>When receiving the request, the client MUST parse the query
          parameters to calculate and validate the hash value as described in
          <xref target="interaction-hash"/>. If the hash validates, the client
          sends a continuation request to the AS as described in <xref
          target="continue-after-interaction"/> using the interaction
          reference value received here.</t>
        </section>

        <section anchor="interaction-pushback"
                 title="Finalizing Interaction with a Pushback URI">
          <t>When using the <xref
          target="response-interact-pushback">"pushback" interaction
          capability</xref>, the AS signals to the client that interaction is
          complete and the request can be continued by sending an HTTP POST
          request to the client's pushback URL sent in <xref
          target="request-interact-pushback">the pushback request</xref>.</t>

          <t>The entity message body is a JSON object consisting of the
          following two elements:</t>

          <t><list style="hanging">
              <t hangText="hash">REQUIRED. The interaction hash value as
              described in <xref target="interaction-hash"/>.</t>

              <t hangText="interact_ref">REQUIRED. The interaction reference
              generated for this interaction.</t>
            </list></t>

          <figure>
            <artwork><![CDATA[POST /push/554321 HTTP/1.1
Host: client.example.net
Content-Type: application/json

{
  "hash": "p28jsq0Y2KK3WS__a42tavNC64ldGTBroywsWxT4md_jZQ1R2HZT8BOWYHcLmObM7XHPAdJzTZMtKBsaraJ64A",
  "interact_ref": "4IFWWIKYBC2PQ6U56NL1"
}
]]></artwork>
          </figure>

          <t/>

          <t>When receiving the request, the client MUST parse the JSON object
          and validate the hash value as described in <xref
          target="interaction-hash"/>. If the hash validates, the client sends
          a continuation request to the AS as described in <xref
          target="continue-after-interaction"/> using the interaction
          reference value received here.</t>
        </section>

        <section anchor="interaction-hash"
                 title="Calculating the interaction hash">
          <t>The "hash" parameter in the callback and pushback response ties
          the front channel response to an ongoing request by using values
          known only to the parties involved. This prevents several kinds of
          session fixation attacks against the client.</t>

          <t>To calculate the "hash" value, the party doing the calculation
          first takes the "nonce" value sent by the RC in the <xref
          target="request-interact-callback">interaction section of the
          initial request</xref>, the AS's nonce value, and the "interact_ref"
          returned in the callback response. For a "callback" return, the AS
          nonce is the "callback_server_nonce" value in <xref
          target="response-interact-callback">the callback response</xref>,
          while for a "pushback" return the AS nonce is the
          "pushback_server_nonce" value in <xref
          target="response-interact-pushback">the pushback response</xref>.
          These three values are concatenated to each other in this order
          using a single newline character as a separator between the fields.
          There is no padding or whitespace before or after any of the lines,
          and no trailing newline character.</t>

          <figure>
            <artwork><![CDATA[VJLO6A4CAYLBXHTR0KRO
MBDOFXG4Y5CVJCX821LH
4IFWWIKYBC2PQ6U56NL1]]></artwork>
          </figure>

          <t/>

          <t>The party then hashes this string with the appropriate algorithm
          based on the "hash_method" parameter of the "callback" or "pushback"
          request. If the "hash_method" value is not present in the RC's
          request, the algorithm defaults to "sha3". [[ Editor's note: these
          hash algorithms should be pluggable, and ideally we shouldn't
          redefine yet another crypto registry for this purpose, but I'm not
          convinced an appropriate one already exists. ]]</t>

          <section title="SHA3">
            <t>The "sha3" hash method consists of hashing the input string
            with the 512-bit SHA3 algorithm. The byte array is then encoded
            using URL Safe Base64 with no padding. The resulting string is the
            hash value.</t>

            <figure>
              <artwork><![CDATA[p28jsq0Y2KK3WS__a42tavNC64ldGTBroywsWxT4md_jZQ1R2HZT8BOWYHcLmObM7XHPAdJzTZMtKBsaraJ64A]]></artwork>
            </figure>
          </section>

          <section title="SHA2">
            <t>The "sha2" hash method consists of hashing the input string
            with the 512-bit SHA2 algorithm. The byte array is then encoded
            using URL Safe Base64 with no padding. The resulting string is the
            hash value.</t>

            <figure>
              <artwork><![CDATA[62SbcD3Xs7L40rjgALA-ymQujoh2LB2hPJyX9vlcr1H6ecChZ8BNKkG_HrOKP_Bpj84rh4mC9aE9x7HPBFcIHw]]></artwork>
            </figure>
          </section>
        </section>
      </section>
    </section>

    <section anchor="continue-request" title="Continuing a Grant Request">
      <t>If the client receives a continuation element in its response <xref
      target="response-continue"/>, the client can make an HTTP POST call to
      the continuation URI with a JSON object. The client MUST send the handle
      reference from the continuation element in its request as a top-level
      JSON parameter.</t>

      <figure>
        <artwork><![CDATA[{
  "handle": "tghji76ytghj9876tghjko987yh"
}]]></artwork>
      </figure>

      <t/>

      <t>The client MAY include other parameters as described here or as
      defined [[ in a registry TBD ]]. [[ Editor's note: We probably want to
      allow other parameters, like modifying the resources requested or
      providing more user information. We'll certainly have some kinds of
      specific challenge-response protocols as there's already been interest
      in that kind of thing, and the continuation request is the place where
      that would fit. ]]</t>

      <t>If a "wait" parameter was included in the continuation response, the
      client MUST NOT call the continuation URI prior to waiting the number of
      seconds indicated. If no "wait" period is indicated, the client SHOULD
      wait at least 5 seconds [[ Editor's note: what's a reasonable amount of
      time so as not to DOS the server?? ]].</t>

      <t>The response from the AS is a JSON object and MAY contain any of the
      elements described in <xref target="response"/>, with some
      variations:</t>

      <t>If the AS determines that the client can make a further continuation
      request, the AS MUST include a new "continue" response element. The
      returned handle value MUST NOT be the same as that used to make the
      continuation request, and the continuation URI MAY remain the same.</t>

      <t>If the AS determines that the client still needs to drive interaction
      with the user, the AS MAY return appropriate responses for any of the
      interaction mechanisms. Unique values such as interaction URIs and
      nonces SHOULD be re-generated and not re-used.</t>

      <t>The client MUST present proof of the same <xref
      target="request-key">key identified in the initial request</xref> by
      signing the request as described in <xref target="binding-keys"/>.</t>

      <section anchor="continue-after-interaction"
               title="Continuing after a Finalized Interaction">
        <t>If the client has received an interaction reference from a <xref
        target="interaction-callback">"callback"</xref> or <xref
        target="interaction-pushback">"pushback"</xref> incoming message, the
        client MUST include the "interaction_ref" in its continuation request.
        Note that the client validates the hash before making the continuation
        request, but the client does not send the hash back to the AS.</t>

        <figure>
          <artwork><![CDATA[{
  "handle": "tghji76ytghj9876tghjko987yh",
  "interact_ref": "4IFWWIKYBC2PQ6U56NL1"
}]]></artwork>
        </figure>

        <t/>
      </section>

      <section anchor="continue-after-tokens"
               title="Continuing after Tokens are Issued">
        <t>A request MAY be continued even after access tokens have been
        issued, so long as the handle is valid.</t>
      </section>
    </section>

    <section anchor="token-management" title="Token Management">
      <t>If an access token response includes the "manage" parameter as
      described in <xref target="response-token-single"/>, the client MAY call
      this URL to manage the access token with the following actions.</t>

      <t>The client MUST present proof of the same <xref
      target="request-key">key identified in the initial request</xref> as
      described in <xref target="binding-keys"/>.</t>

      <section anchor="rotate-access-token" title="Rotating the Access Token">
        <t>The client makes an HTTP POST to the token management URI, signing
        the request with its key. If the token was issued to the client
        identified by the key, the AS will invalidate the current access token
        associated with this URL, if possible, and return a new access token
        response as described in <xref target="response-token-single"/>. Note
        that this MAY include an updated access token management URL.</t>
      </section>

      <section anchor="revoke-access-token" title="Revoking the Access Token">
        <t>The client makes an HTTP DELETE request to the token management
        URI, signing the request with its key. If the token was issued to the
        client identified by the key, the AS will invalidate the current
        access token associated with this URL, if possible, and return an HTTP
        201 response code.</t>
      </section>
    </section>

    <section anchor="send-access-token" title="Sending Access Tokens">
      <t>The method used to send an access token depends on the value of the
      "proof" parameter in <xref target="response-token-single">the access
      token response</xref>.</t>

      <t>If this value is "bearer", the access token is sent using the HTTP
      Header method defined in <xref target="RFC6750"/>.</t>

      <figure>
        <artwork><![CDATA[Authorization: Bearer OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0]]></artwork>
      </figure>

      <t/>

      <t>If the "proof" value is any other string, the access token is sent
      using the HTTP authorization scheme "GNAP" along with a key proof as
      described in <xref target="binding-keys"/> for the key bound to the
      access token. For example, a "jwsd"-bound access token is sent as
      follows:</t>

      <figure>
        <artwork><![CDATA[Authorization: GNAP OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0
JWS-Signature: eyj0....]]></artwork>
      </figure>

      <t/>

      <t>[[ Editor's note: I don't actually like the idea of using only one
      header type for differently-bound access tokens, but instead these
      values should somehow reflect the key binding types. Maybe there can be
      multiple fields after the "GNAP" keyword using structured headers? Or a
      set of derived headers like GNAP-mtls? This might also be better as a
      separate specification, like OAuth 2. ]]</t>
    </section>

    <section anchor="binding-keys" title="Binding Keys">
      <t>Any keys presented by the RC to the AS or RS MUST be validated as
      part of the request in which they are presented. The type of binding
      used is indicated by the proof parameter of the key section in the
      initial request <xref target="request-key"/>. Values defined by this
      specification are as follows:</t>

      <t><list style="hanging">
          <t hangText="jwsd">A detached JWS signature header</t>

          <t hangText="jws">Attached JWS payload</t>

          <t hangText="mtls">Mutual TLS certificate verification</t>

          <t hangText="dpop">OAuth DPoP key proof header</t>

          <t hangText="httpsig">HTTP Signing signature header</t>

          <t hangText="oauthpop">OAuth PoP key proof authentication header</t>
        </list></t>

      <t>Additional values can be defined by [[ a registry TBD ]].</t>

      <t>The keys presented by the RC in the request<xref target="request"/>
      MUST be proved in all continuation requests<xref
      target="continue-request"/> and token management requests <xref
      target="token-management"/>. The AS MUST validate all keys presented by
      the RC or referenced in the transaction at each call to the transaction
      endpoint. The client MUST NOT use a different key during the
      transaction.</t>

      <section anchor="detached-jws" title="Detached JWS">
        <t>This method is indicated by <spanx style="verb">jwsd</spanx> in the
        <spanx style="verb">proof</spanx> field of a key request. To sign a
        request to the transaction endpoint, the RC takes the serialized body
        of the request and signs it using detached JWS <xref
        target="RFC7797"/>. The header of the JWS MUST contain the kid field
        of the key bound to this RC during this transaction. The JWS header
        MUST contain an alg field appropriate for the key identified by kid
        and MUST NOT be none.</t>

        <t>The RC presents the signature in the JWS-Signature HTTP Header
        field. [Editor's Note: this is a custom header field, do we need
        this?]</t>

        <figure>
          <artwork><![CDATA[JWS-Signature: eyj0....]]></artwork>
        </figure>

        <t/>

        <t>When the AS receives the JWS-Signature header, it MUST parse its
        contents as a detached JWS object. The HTTP Body is used as the
        payload for purposes of validating the JWS, with no
        transformations.</t>

        <t>[[ Editor's note: this is a potentially fragile signature mechanism
        but it's simple to calculate. ]]</t>
      </section>

      <section title="Attached JWS">
        <t>This method is indicated by <spanx style="verb">jws</spanx> in the
        <spanx style="verb">proof</spanx> field of a key request. To sign a
        request to the transaction endpoint, the RC takes the serialized body
        of the request JSON and signs it using JWS <xref target="RFC7515"/>.
        The header of the JWS MUST contain the kid field of the key bound to
        this RC during this transaction. The JWS header MUST contain an alg
        field appropriate for the key identified by kid and MUST NOT be
        none.</t>

        <t>The RC presents the JWS as the body of the request along with a
        content type of <spanx style="verb">application/jose</spanx>. The AS
        MUST extract the payload of the JWS and treat it as the request body
        for further processing.</t>
      </section>

      <section anchor="mtls" title="Mutual TLS">
        <t>This method is indicated by <spanx style="verb">mtls</spanx> in the
        <spanx style="verb">proof</spanx> field of a key request. The RC
        presents its client certificate during TLS negotiation with the server
        (either AS or RS). The AS or RS takes the thumbprint of the client
        certificate presented during mutual TLS negotiation and compares that
        thumbprint to the thumbprint presented by the RC application as
        described in <xref target="RFC8705"/> section 3.</t>
      </section>

      <section title="DPoP">
        <t>This method is indicated by <spanx style="verb">dpop</spanx> in the
        <spanx style="verb">proof</spanx> field of a key request. The RC
        creates a DPoP signature header as described in <xref
        target="I-D.ietf-oauth-dpop"/> section 2.</t>
      </section>

      <section title="HTTP Signing">
        <t>This method is indicated by <spanx style="verb">httpsig</spanx> in
        the <spanx style="verb">proof</spanx> field of a key request. The RC
        creates an HTTP Signature header as described in <xref
        target="I-D.ietf-httpbis-message-signatures"/> section 4. The RC MUST
        calculate and present the Digest header as defined in <xref
        target="RFC3230"/>.</t>
      </section>

      <section title="OAuth PoP">
        <t>This method is indicated by <spanx style="verb">oauthpop</spanx> in
        the <spanx style="verb">proof</spanx> field of a key request. The RC
        creates an HTTP Authorization PoP header as described in <xref
        target="I-D.ietf-oauth-signed-http-request"/> section 4, with the
        following additional requirements:</t>

        <t><list style="symbols">
            <t>The at (access token) field MUST be omitted [note: this is in
            contrast to the requirements in the existing spec]</t>

            <t>The b (body hash) field MUST be calculated and supplied</t>
          </list></t>
      </section>
    </section>

    <section title="Discovery">
      <t>By design, the protocol minimizes the need for any pre-flight
      discovery. To begin a transaction, the RC only needs to know the
      transaction endpoint of the AS, and everything else can be negotiated
      dynamically.</t>

      <t>If the RC wants to optimize its calls to the AS, it MAY send an HTTP
      OPTIONS request to the transaction endpoint to retrieve the server's
      discovery information. The AS MUST respond with a JSON document
      containing the following information:</t>

      <t><list style="hanging">
          <t hangText="grant_request_endpoint">REQUIRED. The full URL of the
          AS's grant request endpoint. This MUST match the URL the RC used to
          make the discovery request.</t>

          <t hangText="capabilities">OPTIONAL. A list of the AS's
          capabilities. The values of this result MAY be used by the RC in the
          <xref target="request-capabilities">capabilities section</xref> of
          the request.</t>

          <t hangText="interaction_methods">OPTIONAL. A list of the AS's
          interaction methods. The values of this list correspond to the
          possible fields in the <xref target="request-interact">interaction
          section</xref> of the request.</t>

          <t hangText="key_proofs">OPTIONAL. A list of the AS's supported key
          proofing mechanisms. The values of this list correspond to possible
          values of the <spanx style="verb">proof</spanx> field of the <xref
          target="request-key">key section</xref> of the request.</t>

          <t hangText="sub-ids">OPTIONAL. A list of the AS's supported
          identifiers. The values of this list correspond to possible values
          of the <xref target="request-subject">subject identifier
          section</xref> of the request.</t>

          <t hangText="assertions">OPTIONAL. A list of the AS's supported
          assertion formats. The values of this list correspond to possible
          values of the <xref target="request-subject">subject assertion
          section</xref> of the request.</t>
        </list></t>

      <t>The information returned from this method is for optimization
      purposes only. The AS MAY deny any request, or any portion of a request,
      even if it lists a capability as supported. For example, a given client
      can be registered with the <spanx style="verb">mtls</spanx> key proofing
      mechanism, but the AS also returns other proofing methods, then the AS
      will deny a request from that client using a different proofing
      mechanism.</t>
    </section>

    <section title="Requesting a Resources Without a Token">
      <t>If the client calls an RS without an access token, the RS MAY respond
      to the client with an authentication header indicating that GNAP can be
      used in the "as_uri" parameter. The RS MAY additionally return a
      resource reference that the client MAY use in its resource request <xref
      target="request-resource">req</xref>. This resource reference handle
      SHOULD be sufficient for at least the action the client was attempting
      to take at the RS. The means of the RS obtaining or generating this
      resource reference are out of scope for this specification. [[ Editor's
      note: This could be statically configured at the RS, but we could also
      specify a simple protocol for an RS to send some kind of resource
      description to the AS, tied to the RS's keys, and get back an identifier
      to hand to the client. ]]</t>

      <figure>
        <artwork><![CDATA[WWW-Authenticate: GNAP as_uri=http://server.example/transaction,resource=FWWIKYBQ6U56NL1]]></artwork>
      </figure>

      <t/>

      <t>The client then makes a call to the "as_uri" as described in , with
      the value of "resource" as one of the members of the "resources" array
      <xref target="request-resource-single"/>. The client MAY request
      additional resources and additional information.</t>

      <t>[[ Editor's note: this borrow's heavily from UMA 2's "distributed
      authorization" model and, like UMA, might be better suited to an
      extension than the core protocol. ]]</t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The author would like to thank the feedback of the GNAP working
      group.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>[[ TBD: There are a lot of items in the document that are expandable
      through the use of value registries. ]]</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>[[ TBD: There are a lot of security considerations to add. ]]</t>

      <t>All requests have to be over TLS or equivalent. Many handles act as
      shared secrets, though they can be combined with a requirement to
      provide proof of a key as well.</t>
    </section>

    <section anchor="Privacy" title="Privacy Considerations">
      <t>[[ TBD: There are a lot of privacy considerations to add. ]]</t>

      <t>Handles are passed between parties and therefore should be stateful
      and not contain any internal structure or information, which could leak
      private data.</t>

      <t>When user information is passed to the client, the AS needs to make
      sure that it has the permission to do so.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119.xml'?>

      <?rfc include='reference.RFC.3230.xml'?>

      <?rfc include='reference.RFC.7515.xml'?>

      <?rfc include='reference.RFC.6750.xml'?>

      <?rfc include='reference.RFC.7797.xml'?>

      <?rfc include='reference.RFC.8174.xml'?>

      <?rfc include='reference.RFC.8259.xml'?>

      <?rfc include='reference.RFC.8705.xml'?>

      <?rfc include='reference.I-D.ietf-httpbis-message-signatures.xml'?>

      <?rfc include='reference.I-D.ietf-oauth-signed-http-request.xml'?>

      <?rfc include='reference.I-D.ietf-oauth-dpop.xml'?>

      <?rfc include='reference.I-D.ietf-secevent-subject-identifiers.xml'?>

      <reference anchor="BCP195"
                 target="http://www.rfc-editor.org/info/bcp195">
        <front>
          <title>Recommendations for Secure Use of Transport Layer Security
          (TLS) and Datagram Transport Layer Security (DTLS)</title>

          <author fullname="Y. Sheffer" initials="Y." surname="Sheffer">
            <organization/>
          </author>

          <author fullname="R. Holz" initials="R." surname="Holz">
            <organization/>
          </author>

          <author fullname="P. Saint-Andre" initials="P."
                  surname="Saint-Andre">
            <organization/>
          </author>

          <date month="May" year="2015"/>

          <abstract>
            <t>Transport Layer Security (TLS) and Datagram Transport Layer
            Security (DTLS) are widely used to protect data exchanged over
            application protocols such as HTTP, SMTP, IMAP, POP, SIP, and
            XMPP. Over the last few years, several serious attacks on TLS have
            emerged, including attacks on its most commonly used cipher suites
            and their modes of operation. This document provides
            recommendations for improving the security of deployed services
            that use TLS and DTLS. The recommendations are applicable to the
            majority of use cases.</t>
          </abstract>
        </front>

        <seriesInfo name="BCP" value="195"/>

        <seriesInfo name="RFC" value="7525"/>

        <seriesInfo name="DOI" value="10.17487/RFC7525"/>

        <format octets="60283" type="ASCII"/>
      </reference>
    </references>

    <section title="Document History">
      <t>-09</t>

      <t><list style="symbols">
          <t>Major document refactoring based on request and response
          capabilities.</t>

          <t>Changed from "claims" language to "subject identifier"
          language.</t>

          <t>Added "pushback" interaction capability.</t>

          <t>Removed DIDCOMM interaction (better left to extensions).</t>

          <t>Excised "transaction" language in favor of "Grant" where
          appropriate.</t>

          <t>Added token management URLs.</t>

          <t>Added separate grant continuation URL to use continuation handle
          with.</t>

          <t>Expanded RS-first idea slightly.</t>

          <t>Added notion of extending a grant request based on a previous
          grant.</t>
        </list></t>

      <t>-08</t>

      <t><list style="symbols">
          <t>Added attached JWS signature method.</t>

          <t>Added discovery methods.</t>
        </list></t>

      <t>-07</t>

      <t><list style="symbols">
          <t>Marked sections as being controlled by a future registry TBD.</t>
        </list></t>

      <t>-06</t>

      <t><list style="symbols">
          <t>Added multiple resource requests and multiple access token
          response.</t>
        </list></t>

      <t>-05</t>

      <t><list style="symbols">
          <t>Added "claims" request and response for identity support.</t>

          <t>Added "capabilities" request for inline discovery support.</t>
        </list></t>

      <t>- 04</t>

      <t><list style="symbols">
          <t>Added crypto agility for callback return hash.</t>

          <t>Changed "interaction_handle" to "interaction_ref".</t>
        </list></t>

      <t>- 03</t>

      <t><list style="symbols">
          <t>Removed "state" in favor of "nonce".</t>

          <t>Created signed return parameter for front channel return.</t>

          <t>Changed "client" section to "display" section, as well as
          associated handle.</t>

          <t>Changed "key" to "keys".</t>

          <t>Separated key proofing from key presentation.</t>

          <t>Separated interaction methods into booleans instead of "type"
          field.</t>
        </list></t>

      <t>- 02</t>

      <t><list style="symbols">
          <t>Minor editorial cleanups.</t>
        </list></t>

      <t>- 01</t>

      <t><list style="symbols">
          <t>Made JSON multimodal for handle requests.</t>

          <t>Major updates to normative language and references throughout
          document.</t>

          <t>Allowed interaction to split between how the user gets to the AS
          and how the user gets back.</t>
        </list></t>

      <t>- 00</t>

      <t><list style="symbols">
          <t>Initial submission.</t>
        </list></t>
    </section>

    <section anchor="examples" title="Example Protocol Flows">
      <t>The protocol defined in this specification provides a number of
      features that can be combined to solve many different kinds of
      authentication scenarios. This section seeks to show examples of how the
      protocol would be applied for different situations.</t>

      <t>Some longer fields, particularly cryptographic information, have been
      truncated for display purposes in these examples.</t>

      <section title="Redirect-Based User Interaction">
        <t>In this scenario, the user is the RO and has access to a web
        browser, and the client can take front-channel callbacks on the same
        device as the user. This combination is analogous to the OAuth 2
        Authorization Code grant type.</t>

        <t>The client initiates the request to the AS. Here the client
        identifies itself using its public key.</t>

        <figure>
          <artwork><![CDATA[POST /tx HTTP/1.1
Host: server.example.com
Content-type: application/json
Detached-JWS: ejy0...

{
    "resources": [
        {
            "actions": [
                "read",
                "write",
                "dolphin"
            ],
            "locations": [
                "https://server.example.net/",
                "https://resource.local/other"
            ],
            "datatypes": [
                "metadata",
                "images"
            ]
        }
    ],
    "key": {
        "proof": "jwsd",
        "jwk": {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "xyz-1",
            "alg": "RS256",
            "n": "kOB5rR4Jv0GMeLaY6_It_r3ORwdf8ci_JtffXyaSx8xY..."
        }
    },
    "interact": {
        "redirect": true,
        "callback": {
            "uri": "https://client.example.net/return/123455",
            "nonce": "LKLTI25DK82FX4T4QFZC"
        }
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The AS processes the request and determines that the RO needs to
        interact. The AS returns the following response giving the client the
        information it needs to connect. The AS has also indicated to the
        client that it can use the given key handle to identify itself in
        future calls.</t>

        <figure>
          <artwork><![CDATA[Content-type: application/json

{
    "interaction_url": "https://server.example.com/interact/4CF492MLVMSW9MKMXKHQ",
    "server_nonce": "MBDOFXG4Y5CVJCX821LH",
    "continue": {
        "handle": "80UPRY5NM33OMUKMKSKU",
        "uri": "https://server.example.com/continue"
    },
    "key_handle": "7C7C4AZ9KHRS6X63AJAO"
}]]></artwork>
        </figure>

        <t/>

        <t>The client saves the response and redirects the user to the
        interaction_url by sending the following HTTP message to the user's
        browser.</t>

        <figure>
          <artwork><![CDATA[HTTP 302 Found
Location: https://server.example.com/interact/4CF492MLVMSW9MKMXKHQ]]></artwork>
        </figure>

        <t/>

        <t>The user's browser fetches the AS's interaction URL. The user logs
        in, is identified as the RO for the resource being requested, and
        approves the request. Since the AS has a callback parameter, the AS
        generates the interaction reference, calculates the hash, and
        redirects the user back to the client with these additional values
        added as query parameters.</t>

        <figure>
          <artwork><![CDATA[HTTP 302 Found
Location: https://client.example.net/return/123455
  ?hash=p28jsq0Y2KK3WS__a42tavNC64ldGTBroywsWxT4md_jZQ1R2HZT8BOWYHcLmObM7XHPAdJzTZMtKBsaraJ64A
  &interact_ref=4IFWWIKYBC2PQ6U56NL1]]></artwork>
        </figure>

        <t/>

        <t>The client receives this request from the user's browser. The
        client ensures that this is the same user that was sent out by
        validating session information and retrieves the stored pending
        request. The client uses the values in this to validate the hash
        parameter. The client then calls the continuation URL and presents the
        handle and interaction reference in the request body. The client signs
        the request as above.</t>

        <figure>
          <artwork><![CDATA[POST /continue HTTP/1.1
Host: server.example.com
Content-type: application/json
Detached-JWS: ejy0...


{
    "handle": "80UPRY5NM33OMUKMKSKU",
    "interact_ref": "4IFWWIKYBC2PQ6U56NL1"
}]]></artwork>
        </figure>

        <t/>

        <t>The AS retrieves the pending request based on the handle and issues
        a bearer access token and returns this to the client.</t>

        <figure>
          <artwork><![CDATA[Content-type: application/json

{
    "access_token": {
        "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
        "proof": "bearer",
        "manage": "https://server.example.com/token/PRY5NM33OM4TB8N6BW7OZB8CDFONP219RP1L",
        "resources": [{
            "actions": [
                "read",
                "write",
                "dolphin"
            ],
            "locations": [
                "https://server.example.net/",
                "https://resource.local/other"
            ],
            "datatypes": [
                "metadata",
                "images"
            ]
        }]
    },
    "continue": {
        "handle": "80UPRY5NM33OMUKMKSKU",
        "uri": "https://server.example.com/continue"
    }
}]]></artwork>
        </figure>

        <t/>
      </section>

      <section title="Secondary Device Interaction">
        <t>In this scenario, the user does not have access to a web browser on
        the device and must use a secondary device to interact with the AS.
        The client can display a user code or a printable QR code. The client
        prefers a short URL if one is available.</t>

        <t>The client initiates the request to the AS.</t>

        <figure>
          <artwork><![CDATA[POST /tx HTTP/1.1
Host: server.example.com
Content-type: application/json
Detached-JWS: ejy0...

{
    "resources": [
        "dolphin-metadata", "some other thing"
    ],
    "key": "7C7C4AZ9KHRS6X63AJAO",
    "interact": {
        "redirect": true,
        "short_redirect": true,
        "user_code": true
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The AS processes this and determines that the RO needs to interact.
        The AS supports both long and short redirect URIs for interaction, so
        it includes both. Since there is no "callback" the AS does not include
        a nonce, but does include a "wait" parameter on the continuation
        section because it expects the client to poll for results.</t>

        <figure>
          <artwork><![CDATA[Content-type: application/json

{
    "interaction_url": "https://server.example.com/interact/4CF492MLVMSW9MKMXKHQ",
    "short_interaction_url": "https://srv.ex/MXKHQ",
    "user_code": {
        "code": "A1BC-3DFF",
        "url": "https://srv.ex/device"
    },
    "continue": {
        "handle": "80UPRY5NM33OMUKMKSKU",
        "uri": "https://server.example.com/continue",
        "wait": 60
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The client saves the response and displays the user code visually
        on its screen along with the static device URL. The client also
        displays the short interaction URL as a QR code to be scanned.</t>

        <t>If the user scans the code, they are taken to the interaction
        endpoint and the AS looks up the current pending request based on the
        incoming URL. If the user instead goes to the static page and enters
        the code manually, the AS looks up the current pending request based
        on the value of the user code. In both cases, the user logs in, is
        identified as the RO for the resource being requested, and approves
        the request. Once the request has been approved, the AS displays to
        the user a message to return to their device.</t>

        <t>Meanwhile, the client periodically polls the AS every 60 seconds at
        the continuation URL.</t>

        <figure>
          <artwork><![CDATA[POST /continue HTTP/1.1
Host: server.example.com
Content-type: application/json
Detached-JWS: ejy0...


{
    "handle": "80UPRY5NM33OMUKMKSKU"
}]]></artwork>
        </figure>

        <t/>

        <t>The AS retrieves the pending request based on the handle and
        determines that it has not yet been authorized. The AS indicates to
        the client that no access token has yet been issued but it can
        continue to call after another 60 second timeout.</t>

        <figure>
          <artwork><![CDATA[Content-type: application/json

{
    "continue": {
        "handle": "BI9QNW6V9W3XFJK4R02D",
        "uri": "https://server.example.com/continue",
        "wait": 60
    }
}]]></artwork>
        </figure>

        <t/>

        <t>Note that the continuation handle has been rotated since it was
        used by the client to make this call. The client polls the
        continuation URL after a 60 second timeout using the new handle.</t>

        <figure>
          <artwork><![CDATA[POST /continue HTTP/1.1
Host: server.example.com
Content-type: application/json
Detached-JWS: ejy0...


{
    "handle": "BI9QNW6V9W3XFJK4R02D"
}]]></artwork>
        </figure>

        <t/>

        <t>The AS retrieves the pending request based on the handle and
        determines that it has been approved and it issues an access
        token.</t>

        <figure>
          <artwork><![CDATA[Content-type: application/json

{
    "access_token": {
        "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
        "proof": "bearer",
        "manage": "https://server.example.com/token/PRY5NM33OM4TB8N6BW7OZB8CDFONP219RP1L",
        "resources": [
            "dolphin-metadata", "some other thing"
        ]
    }
}]]></artwork>
        </figure>

        <t/>
      </section>

      <section title="No User Involvement">
        <t>In this scenario, the client is requesting access on its own
        behalf, with no user to interact with.</t>

        <t>The client creates a request to the AS, identifying itself with its
        public key and using MTLS to make the request.</t>

        <figure>
          <artwork><![CDATA[POST /tx HTTP/1.1
Host: server.example.com
Content-type: application/json

{
    "resources": [
        "backend service", "nightly-routine-3"
    ],
    "key": {
        "proof": "mtls",
        "cert#S256": "bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2"
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The AS processes this and determines that the client can ask for
        the requested resources and issues an access token.</t>

        <figure>
          <artwork><![CDATA[Content-type: application/json

{
    "access_token": {
        "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
        "proof": "bearer",
        "manage": "https://server.example.com/token/PRY5NM33OM4TB8N6BW7OZB8CDFONP219RP1L",
        "resources": [
            "backend service", "nightly-routine-3"
        ]
    }
}]]></artwork>
        </figure>
      </section>

      <section title="Asynchronous Authorization">
        <t>In this scenario, the client is requesting on behalf of a specific
        RO, but has no way to interact with the user. The AS can
        asynchronously reach out to the RO for approval in this scenario.</t>

        <t>The client starts the request at the AS by requesting a set of
        resources. The client also identifies a particular user.</t>

        <figure>
          <artwork><![CDATA[POST /tx HTTP/1.1
Host: server.example.com
Content-type: application/json
Detached-JWS: ejy0...

{
    "resources": [
        {
            "type": "photo-api",
            "actions": [
                "read",
                "write",
                "dolphin"
            ],
            "locations": [
                "https://server.example.net/",
                "https://resource.local/other"
            ],
            "datatypes": [
                "metadata",
                "images"
            ]
        },
        "read", "dolphin-metadata",
        {
            "type": "financial-transaction",
            "actions": [
                "withdraw"
            ],
            "identifier": "account-14-32-32-3", 
            "currency": "USD"
        },
        "some other thing"
    ],
    "key": "7C7C4AZ9KHRS6X63AJAO",
    "user": {
        "sub-ids": [ {
            "subject_type": "email",
            "email": "user@example.com"
        } ]
   }
}]]></artwork>
        </figure>

        <t/>

        <t>The AS processes this and determines that the RO needs to interact.
        The AS determines that it can reach the identified user asynchronously
        and that the identified user does have the ability to approve this
        request. The AS indicates to the client that it can poll for
        continuation.</t>

        <figure>
          <artwork><![CDATA[Content-type: application/json

{
    "continue": {
        "handle": "80UPRY5NM33OMUKMKSKU",
        "uri": "https://server.example.com/continue",
        "wait": 60
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The AS reaches out to the RO and prompts them for consent. In this
        example, the AS has an application that it can push notifications in
        to for the specified account. </t>

        <t>Meanwhile, the client periodically polls the AS every 60 seconds at
        the continuation URL.</t>

        <figure>
          <artwork><![CDATA[POST /continue HTTP/1.1
Host: server.example.com
Content-type: application/json
Detached-JWS: ejy0...


{
    "handle": "80UPRY5NM33OMUKMKSKU"
}]]></artwork>
        </figure>

        <t/>

        <t>The AS retrieves the pending request based on the handle and
        determines that it has not yet been authorized. The AS indicates to
        the client that no access token has yet been issued but it can
        continue to call after another 60 second timeout.</t>

        <figure>
          <artwork><![CDATA[Content-type: application/json

{
    "continue": {
        "handle": "BI9QNW6V9W3XFJK4R02D",
        "uri": "https://server.example.com/continue",
        "wait": 60
    }
}]]></artwork>
        </figure>

        <t/>

        <t>Note that the continuation handle has been rotated since it was
        used by the client to make this call. The client polls the
        continuation URL after a 60 second timeout using the new handle.</t>

        <figure>
          <artwork><![CDATA[POST /continue HTTP/1.1
Host: server.example.com
Content-type: application/json
Detached-JWS: ejy0...


{
    "handle": "BI9QNW6V9W3XFJK4R02D"
}]]></artwork>
        </figure>

        <t/>

        <t>The AS retrieves the pending request based on the handle and
        determines that it has been approved and it issues an access
        token.</t>

        <figure>
          <artwork><![CDATA[Content-type: application/json

{
    "access_token": {
        "value": "OS9M2PMHKUR64TB8N6BW7OZB8CDFONP219RP1LT0",
        "proof": "bearer",
        "manage": "https://server.example.com/token/PRY5NM33OM4TB8N6BW7OZB8CDFONP219RP1L",
        "resources": [
            "dolphin-metadata", "some other thing"
        ]
    }
}]]></artwork>
        </figure>

        <t/>
      </section>

      <section title="Applying OAuth 2 Scopes and Client IDs">
        <t>In this scenario, the client developer has a client_id and set of
        scope values from their OAuth 2 system and wants to apply them to the
        new protocol. Traditionally, the OAuth 2 client developer would put
        their client_id and scope values as parameters into a redirect request
        to the authorization endpoint.</t>

        <figure>
          <artwork><![CDATA[HTTP 302 Found
Location: https://server.example.com/authorize
  ?client_id=7C7C4AZ9KHRS6X63AJAO
  &scope=read%20write%20dolphin
  &redirect_uri=https://client.example.net/return
  &response_type=code
  &state=123455
]]></artwork>
        </figure>

        <t/>

        <t>Now the developer wants to make an analogous request to the AS
        using the new protocol. To do so, the client makes an HTTP POST and
        places the OAuth 2 values in the appropriate places.</t>

        <figure>
          <artwork><![CDATA[POST /tx HTTP/1.1
Host: server.example.com
Content-type: application/json
Detached-JWS: ejy0...

{
    "resources": [
        "read", "write", "dolphin"
    ],
    "key": "7C7C4AZ9KHRS6X63AJAO",
    "interact": {
        "redirect": true,
        "callback": {
            "uri": "https://client.example.net/return?state=123455",
            "nonce": "LKLTI25DK82FX4T4QFZC"
        }
    }
}]]></artwork>
        </figure>

        <t/>

        <t>The client_id can be used to identify the client's keys that it
        uses for authentication, the scopes represent resources that the
        client is requesting, and the redirect_uri and state value are
        combined into a callback URI that can be unique per request. The
        client additionally creates a nonce to protect the callback, separate
        from the state parameter that it has added to its return URL.</t>

        <t>From here, the protocol continues as above.</t>
      </section>
    </section>
  </back>
</rfc>
